; Copyright (C) 2011 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $1f00
jmp main

seeds:         .byte 100, 239, 183   ; $ef, $b7, $90, $d6, $89
start_rooms_x: .byte 5,   3,   5
start_rooms_y: .byte 5,   8,   1
exit_rooms_x:  .byte 7,   9,   3
exit_rooms_y:  .byte 0,   0,   9

; These values need to be kept in sync - the room numbers must match their
; positions in the room array.
key_rooms_x:   .byte 1,   5,  10
key_rooms_y:   .byte 0,   2,   6
key_rooms:     .byte 1,  27,  76    ; ky*11 + kx

treasure_table:  .byte 6, 5, 7, 1, 1, 5, 2, 7, 6, 2, 1, 7, 1, 7, 8, 7
treasure_table_: .byte 0, 7, 6, 7, 7, 7, 5, 0, 6, 3, 7, 7, 5, 7, 5, 0

unlimited_values:   ; $7c,$7d=first,second
                    ; Add $7c and $7d, store the result in $7d and the original
                    ; $7d value in $7c, returning the sum in the accumulator.
    lda $7c
    sta $7b
    lda $7d
    sta $7c
    adc $7b
    sta $7d
    clc
    rts

mod9:               ; A = value
    divide_loop:
        cmp #9
        bcc after_divide_loop   ; bmi should work here, I think, but it doesn't
        sec
        sbc #9
        jmp divide_loop

after_divide_loop:
    clc
    rts             ; A % 9

tile_values_map: .byte 0,1,0,0,0,0,2,3

next_value:         ; no argument
    jsr unlimited_values
    lda $7d
    jsr mod9
    and #7          ; (next value % 9) & 7
    tax
    lda tile_values_map,x
    sta $7b
    rts

; Room filling routines, writing to 0x579c to 0x57ff.

draw_top_line:
    ldx #9
    lda #2

    draw_top_line_loop0:
        sta $579c,x
        dex
        bpl draw_top_line_loop0

    ldx #3                      ; draw the exit or wall
    lda $76
    draw_top_line_loop1:
        sta $579f,x
        dex
        bpl draw_top_line_loop1
    clc
    rts

draw_left_line:
    ldx #90
    draw_left_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop0

    ldx #30
    draw_left_line_loop1:
        lda $77
        sta $57ba,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop1
    clc
    rts

draw_bottom_line:
    ldx #9
    lda #2
    draw_bottom_line_loop0:
        sta $57f6,x
        dex
        bpl draw_bottom_line_loop0

    ldx #3
    lda $76
    draw_bottom_line_loop1:
        sta $57f9,x
        dex
        bpl draw_bottom_line_loop1
    clc
    rts

draw_right_line:
    ldx #99
    draw_right_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop0

    ldx #30
    draw_right_line_loop1:
        lda $77
        sta $57c3,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop1
    clc
    rts

make_room:          ; $78,$79=i,j

    ; Fills the room array at 579c with values.
    ; Tiles 0,1,2,3 are map tiles that will be shown by the plot_tile routine.
    ; Other tiles are plotted separately:
    ;   4 = exit
    ;   5 = final exit
    ;   6 = weapon (bits 3,4 are type)
    ;   7 = treasure (bits 3,4 are type)

    ; Fill the room with empty space.

    ldx #100
    make_empty_room_loop:
        lda #0
        sta $579c,x
        dex
        bpl make_empty_room_loop

    ; Determine if there is a top exit.

    lda #0
    sta $76

    lda $78         ; i == 0
    cmp #0
    bne not_top_screen
    lda #2
    sta $76
    jmp do_top_exit

    not_top_screen:
    clc

    lda $78
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_top_exit
    clc

    lda $78
    eor $79         ; i ^ j
    adc $78         ; + i
    clc
    cmp $79         ; (i ^ j) + i == j
    bne do_top_exit
    lda #2
    sta $76         ; top exit

    do_top_exit:
    jsr draw_top_line

    ; Determine if there is a left exit.
    lda #0
    sta $77

    lda $79
    cmp #0
    bne not_left_screen
    lda #2
    sta $77
    jmp do_left_exit

    not_left_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    and #3          ; j & 3
    cmp $70
    beq do_left_exit
    clc

    lda $78
    ora $79         ; i | j
    eor $79         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_left_exit
    lda #2
    sta $77         ; left exit

    do_left_exit:
    jsr draw_left_line

    ; Determine if there is a right exit.
    lda #0
    sta $77

    lda $79
    cmp #10
    bne not_right_screen
    lda #2
    sta $77
    jmp do_right_exit

    not_right_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    adc #1
    and #3          ; j & 3
    cmp $70
    beq do_right_exit
    clc

    lda $79
    adc #1
    sta $70

    lda $78
    ora $70         ; i | j
    eor $70         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_right_exit
    lda #2
    sta $77         ; right exit

    do_right_exit:
    jsr draw_right_line

    ; Determine if there is a bottom exit.
    lda #0
    sta $76

    lda $78
    cmp #10
    bne not_bottom_screen
    lda #2
    sta $76
    jmp do_bottom_exit

    not_bottom_screen:
    clc

    lda $78
    adc #1
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_bottom_exit
    clc

    lda $78
    adc #1
    sta $70

    eor $79         ; i ^ j
    adc $70         ; + i
    cmp $79         ; (i ^ j) + i == j
    bne do_bottom_exit
    lda #2
    sta $76         ; bottom exit

    do_bottom_exit:
    jsr draw_bottom_line

    ; Make sure that the starting, exit, key rooms are empty.

    ldx $3dfa               ; level number
    lda start_rooms_y,x
    cmp $78
    bne make_room_not_starting_room
    lda start_rooms_x,x
    cmp $79
    bne make_room_not_starting_room

    lda #3
    sta $70
    jmp add_room_decoration ; optimise away the rts

    make_room_not_starting_room:

    lda exit_rooms_y,x
    cmp $78
    bne make_room_not_exit_room
    lda exit_rooms_x,x
    cmp $79
    bne make_room_not_exit_room

    ; Add an exit to the room.
    lda $78
    eor $79
    and #15
    tax
    lda exit_room_offsets,x
    tax
    lda $3df0
    and #1
    beq exit_not_open

    lda #5
    sta $579c,x
    lda #3
    sta $70
    jmp add_room_decoration ; optimise away the rts

    exit_not_open:
    clc
    lda #4
    sta $579c,x
    rts

    make_room_not_exit_room:

    lda key_rooms_y,x
    cmp $78
    bne make_room_not_key_room
    lda key_rooms_x,x
    cmp $79
    bne make_room_not_key_room

    lda #1
    sta $70
    jmp add_room_decoration ; optimise away the rts

    make_room_not_key_room:
    clc

    ; Fill in the room details.

    lda $7f
    adc $79
    sta $7c
    sec
    ldx $3dfa
    lda seeds,x
    sbc $78
    sec
    sbc $7e
    sta $7d
    clc

    ; Discard the first ten values.

    ldy #10
    make_room_loop0:
        jsr unlimited_values
        dey
        bne make_room_loop0
    
    ; Fill the room array with values.

    lda #$a7
    sta $70
    lda #$57
    sta $71

    ldy #0
    make_room_loop1:

        jsr next_value
        sta ($70),y
        iny
        cpy #8
        bne make_room_loop1     ; continue the same row

        lda $70
        cmp #$ed
        beq make_room_loop1_exit    ; exit after the last row

        adc #10
        sta $70
        ldy #0                  ; reset the row counter
        jmp make_room_loop1
    
    make_room_loop1_exit:
    rts

decoration_offsets: .byte 11,18,81,88

add_room_decoration:

    lda #$9c
    sta $8e
    lda #$57
    sta $8f
    
    ldx #3
    add_room_decoration_loop:

        lda decoration_offsets,x
        tay
        lda $70
        sta ($8e),y
        dex
        bpl add_room_decoration_loop
    
    clc
    rts

exit_room_offsets:  .byte 35,66,63,56,34,44,64,33,36,55,65,53,45,46,54,43
treasure_x:         .byte 3, 2, 4, 8, 2, 5, 4, 1, 3, 8, 6, 5, 7, 1, 7, 6
treasure_y:         .byte 1, 3, 7, 7, 2, 3, 6, 1, 4, 6, 8, 5, 5, 4, 8, 2

eleven_times_table: .byte 0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110

add_treasure:               ; $78,$79 = i,j

    lda $78
    tax
    lda eleven_times_table,x
    adc $79
    tax

    lda $5100,x
    ora #$80
    sta $5100,x         ; set the top bit (room visited)
    and #$7f            ; mask off the top bit to obtain the item number + 1
    cmp #0
    beq add_treasure_exit

    sec
    sbc #1
    sta $3d0d           ; store weapon/treasure type
    clc

    lda $78
    eor $79
    adc $3d0d
    and #15
    sta $70

    lda #15
    sta $8c
    ldy #0
    add_treasure_loop:

        clc

        ldx $70
        lda treasure_y,x    ; y
        sta $8d
        tax
        lda room_row_offsets_low,x
        sta $80

        ldx $70
        lda treasure_x,x    ; x
        sta $8e
        adc $80
        sta $80

        lda #$57
        adc #0
        sta $81
        clc

        lda ($80),y         ; tile
        cmp #0
        bne add_treasure_loop_next

        lda #4              ; type (weapon/treasure)
        sta $3d0c
        lda $8d             ; y
        sta $3d0e
        lda #1              ; dy
        sta $3d0f
        lda $8e             ; x
        sta $3d10
        lda #0              ; dx
        sta $3d11

        lda #$0c
        sta $74
        lda #$3d
        sta $75
        jmp plot_character  ; optimise away the rts

        add_treasure_loop_next:
        lda $70
        cmp #0
        bne add_treasure_loop_next2

        lda #15
        sta $70

        add_treasure_loop_next2:
        dec $70
        dec $8c
        bpl add_treasure_loop

    add_treasure_exit:
    clc
    rts

plot:               ; $70,$71=source address
                    ; $72,$73=destination address
    ldy #$1f
    plotloop0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    plotloop1:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$20
        bpl plotloop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    plotloop2:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$40
        bpl plotloop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts



plot_blank_xy:      ; X=y, Y=x

    lda screen_rows_low,x
    sta $72
    lda screen_rows_high,x
    sta $73

    tya
    tax
    lda screen_columns_low,x
    adc $72
    sta $72
    lda screen_columns_high,x
    adc $73
    sta $73
    clc
    ; run on into plot_blank

plot_blank:         ; $72,$73=destination address

    ldy #$1f
    lda #0
    plot_blank_loop0:
        sta ($72),y
        dey
        bpl plot_blank_loop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    lda #0
    plot_blank_loop1:
        sta ($72),y
        dey
        cpy #$20
        bpl plot_blank_loop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    lda #0
    plot_blank_loop2:
        sta ($72),y
        dey
        cpy #$40
        bpl plot_blank_loop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts

tile_addresses_low:  .byte $00, $60, $c0, $00, $60, $c0, $20
tile_addresses_high: .byte $53, $53, $53, $4f, $4f, $4f, $50

plot_tile:          ; $7b=tile number
                    ;   1 = flowers/decoration
                    ;   2 = trees/wall
                    ;   3 = trees
                    ;   4 = exit
                    ;   5 = open exit
                    ;   6 = final exit (left)
                    ;   7 = final exit (right)
                    ; $72,$73=screen position 

    lda $7b
    cmp #0
    bne plot_tile_sprite
    clc
    jmp plot_blank      ; optimise away the rts

    plot_tile_sprite:
    clc
    tax
    dex
    lda tile_addresses_low,x
    sta $70
    lda tile_addresses_high,x
    sta $71

    lda $7b
    cmp #4
    bpl plot_not_blank_after_add_loop   ; don't adjust the tile for later levels
    
    clc
    lda $3dfa
    and #3              ; change the tile set for later levels
    tax
    plot_not_blank_add_loop:
        cpx #0
        beq plot_not_blank_after_add_loop
        clc
        lda $70
        adc #$20
        sta $70
        lda $71
        adc #$01
        sta $71
        dex
        jmp plot_not_blank_add_loop

    plot_not_blank_after_add_loop:
    clc
    jsr plot
    rts

plot_room:          ; $78,$79 = i,j (from $3df2,$3df3)
    jsr blank_screen

    lda $3df2
    sta $78
    lda $3df3
    sta $79

    lda #$80
    sta $72
    lda #$5a
    sta $73         ; $72,$73 = screen position

    jsr make_room

    lda #0
    sta $7a
    row_loop:

        lda #9
        sta $76

        column_loop:
            lda $7a
            tax
            lda $579c,x
            sta $7b
            jsr plot_tile

            lda $7a
            adc #1
            sta $7a
            lda $76
            sec
            sbc #1
            sta $76
            clc
            cmp #0
            bpl column_loop

        clc

        lda $72
        adc #$80
        sta $72
        lda $73
        adc #$02
        sta $73
        clc
        cmp #$80
        beq end_rows

        jmp row_loop
    
end_rows:
    lda #1
    sta $70
    lda $78
    eor $79
    and #3
    tax
    lda room_palettes,x
    sta $71
    jsr set_palette

    lda #2
    sta $70
    sta $71
    jsr set_palette
    lda #3
    sta $70
    sta $71
    jsr set_palette
    rts

room_palettes: .byte 1, 6, 5, 7

plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop8x24_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop8x24_y0_0
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #31

    plotloop8x24_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #16
        bpl plotloop8x24_y0_1
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #47

    plotloop8x24_y0_2:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop8x24_y0_2

    clc
    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c
;
; Write to screen in this arrangement:
; -- --
; 00 08
;
; 04 0c
; 10 18
;
; 14 1c
; 20 28
;
; 24 2c

plot8x24_y1:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2              ; plotting 3 8x8 pieces

    plotloop8x24_y1_loop:

        ldy #3

        plotloop8x24_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y1_0
        clc

        ldy #11

        plotloop8x24_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x24_y1_1
        clc

        lda $70
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldy #3

        plotloop8x24_y1_2:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y1_2
        clc

        ldy #11

        plotloop8x24_y1_3:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x24_y1_3
        clc

        lda $70
        adc #12
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        dex
        bpl plotloop8x24_y1_loop

    clc
    jmp plot_buffer_loop_next

plot16x16_y0:           ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #31

    plotloop16x16_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop16x16_y0_0
    clc

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 32
    clc

    ldy #63

    plotloop16x16_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop16x16_y0_1
    clc

    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c 30 34 38 3c
;
; Write to screen in this arrangement:
; -- -- -- --
; 00 08 10 18
;
; 04 0c 14 1c
; 20 28 30 38
;
; 24 2c 34 3c

plot16x16_y1:           ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #3

    plotloop16x16_y1_loop:

        ldy #3

        plotloop16x16_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop16x16_y1_0
        clc

        ldy #11

        plotloop16x16_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop16x16_y1_1
        clc

        ldy #19

        plotloop16x16_y1_2:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #16
            bpl plotloop16x16_y1_2
        clc

        ldy #27

        plotloop16x16_y1_3:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #24
            bpl plotloop16x16_y1_3
        clc

        dex
        bmi plotloop16x16_y1_exit
        txa
        and #1
        bne plotloop16x16_y1_loop_next

        lda $70         ; add by 4 to start the next half row
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; add 0x140 - 4 to plot the next top half row
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        jmp plotloop16x16_y1_loop

        plotloop16x16_y1_loop_next:
        clc

        lda $70         ; add 28 to start the next row
        adc #$1c
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; add 4 to plot the next half row
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        jmp plotloop16x16_y1_loop

    plotloop16x16_y1_exit:
    clc
    jmp plot_buffer_loop_next

plot8x8_y0:             ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop8x8_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop8x8_y0_0
    clc

    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04
;
; Write to screen in this arrangement:
; --
; 00
;
; 04

plot8x8_y1:             ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #1

    plotloop8x8_y1_loop:

        ldy #3

        plotloop8x8_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x8_y1_0
        clc

        ldy #11

        plotloop8x8_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x8_y1_1
        clc

        dex
        bmi plot8x8_y1_exit
        clc

        lda $70         ; add by 4 to start the next half row
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; subtract by 0x140 - 4 to plot the next top half row
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        jmp plotloop8x8_y1_loop

    plot8x8_y1_exit:
    clc

    jmp plot_buffer_loop_next


check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

key_input:              ; returns A=0 (no key), 1 (left), 2 (right), 3 (up)
                        ;           4 (down), 5 (fire)

    ldx #158            ; -98 (Z)
    jsr check_key
    cpy #255
    bne not_left_key
    lda #1
    rts

not_left_key:
    ldx #189            ; -67 (X)
    jsr check_key
    cpy #255
    bne not_right_key
    lda #2
    rts

not_right_key:
    ldx #183            ; -73 (:)
    jsr check_key
    cpy #255
    bne not_up_key
    lda #3
    rts

not_up_key:
    ldx #151            ; -105 (/)
    jsr check_key
    cpy #255
    bne not_down_key
    lda #4
    rts

not_down_key:
    ldx #182            ; -74 (Return)
    jsr check_key
    cpy #255
    bne not_fire_key
    lda #5
    rts

not_fire_key:
    lda #0
    rts

player_direction_chars_low: .byte $00,$30,$60,$90,$c0,$f0,$20,$50, $80,$b0,$e0,$10
player_direction_chars_high: .byte $3e,$3e,$3e,$3e,$3e,$3e,$3f,$3f, $3f,$3f,$3f,$40

screen_rows_low: .byte $80,$40,$00,$c0,$80,$40,$00,$c0,$80,$40
screen_rows_high: .byte $5a,$5e,$62,$65,$69,$6d,$71,$74,$78,$7c
screen_subrows_low: .byte $00,$04,$40,$44,$80,$84
screen_subrows_high: .byte $00,$00,$01,$01,$02,$02

screen_columns_low: .byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00,$20
screen_columns_high: .byte $00,$00,$00,$00,$00,$00,$00,$00,$01,$01
screen_subcolumns_low: .byte $00,$08,$10,$18

enemy_direction_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80
enemy_direction_chars_high: .byte $40,$41,$41,$41,$41,$42,$42,$42

emerge_explode_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$00,$00
emerge_explode_chars_high: .byte $4a,$4b,$4b,$4b,$4b,$4c,$4c,$4c

item_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80,$c0
item_chars_high: .byte $4c,$4d,$4d,$4d,$4d,$4e,$4e,$4e,$4e

projectile_chars_low: .byte $40,$50,$60,$70,$80,$90,$a0,$b0

unplot_character:       ; $74,$75=character address

    lda $82             ; store the unplot buffer address in $78,$79
    sta $78
    lda $83
    sta $79
    jsr plot_character_sprite
    lda $78
    sta $82             ; update the latest space in the unplot buffer
    rts

plot_character:         ; $74,$75=character address

    lda $84             ; store the plot buffer address in $78,$79
    sta $78
    lda $85
    sta $79
    jsr plot_character_sprite
    lda $78
    sta $84             ; update the latest space in the plot buffer
    rts

plot_character_sprite:  ; $74,$75=character address
                        ; $78,$79=unplot/plot buffer address

    ldy #0
    lda ($74),y
    cmp #0
    bne plot_characters_read_character
    jmp plot_characters_next

    plot_characters_read_character:
    clc

    sta $77         ; temporarily store the object type

    ; Use lookup tables to load the offsets into the sprite.

    ; Direction
    iny
    lda ($74),y
    sta $80         ; temporarily store the direction

    ; y
    iny
    lda ($74),y
    tax
    lda screen_rows_low,x
    sta $72
    lda screen_rows_high,x
    sta $73
    clc

    ; dy
    iny
    lda ($74),y
    sta $76
    tax
    lda screen_subrows_low,x
    adc $72
    sta $72
    lda screen_subrows_high,x
    adc $73
    sta $73
    clc

    ; x
    iny
    lda ($74),y
    tax
    lda screen_columns_low,x
    adc $72
    sta $72
    lda screen_columns_high,x
    adc $73
    sta $73
    clc

    ; dx
    iny
    lda ($74),y
    tax
    lda screen_subcolumns_low,x
    adc $72
    sta $72
    clc

    lda $77
    cmp #1
    bne plot_characters_loop_not_player

    ; Plot 8x24 sprites (player)

    ldx $80
    lda player_direction_chars_low,x
    sta $70
    lda player_direction_chars_high,x
    sta $71

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    lda $76
    and #1
    bne plot_characters_plot_8x24_1

    lda #1
    sta ($78),y
    jmp plot_characters_stored

    plot_characters_plot_8x24_1:
    clc
    lda #2
    sta ($78),y
    jmp plot_characters_stored


    plot_characters_loop_not_player:
    cmp #2
    bne plot_characters_loop_not_projectile

    ; Plot 8x8 sprites (projectiles)

    lda $80
    and #7
    tax
    lda projectile_chars_low,x
    sta $70
    lda #$40
    sta $71

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    lda $76
    and #1
    bne plot_characters_plot_8x8_1

    lda #3
    sta ($78),y
    jmp plot_characters_stored

    plot_characters_plot_8x8_1:
    clc
    lda #4
    sta ($78),y
    jmp plot_characters_stored


    plot_characters_loop_not_projectile:
    cmp #3
    bne plot_characters_loop_not_explosion

    ; Plot 16x16 sprites (emerging, explosions)

    ; Select the sprites to use.

    lda $80
    and #3          ; only keep the bits required to find the correct sprite
    clc
    tax
    lda emerge_explode_chars_low,x
    sta $70
    lda emerge_explode_chars_high,x
    sta $71

    jmp plot_characters_16x16

    plot_characters_loop_not_explosion:
    cmp #4
    bne plot_characters_loop_not_item

    ; Plot 16x16 sprites (items)

    ; Select the sprites to use.

    lda $80
    and #$0f        ; only keep the bits required to find the correct sprite
    clc
    tax
    lda item_chars_low,x
    sta $70
    lda item_chars_high,x
    sta $71

    jmp plot_characters_16x16

    plot_characters_loop_not_item:
    cmp #8
    bmi plot_characters_loop_not_enemy

    ; Plot 16x16 sprites (enemies)

    ; Select the set of sprites to use.

    and #$70
    lsr
    lsr
    lsr     ; bits 4,5,6 >> 3 -> bits 1,2,3
    clc
    sta $71 ; 0x00, 0x02, 0x04, 0x06, 0x08

    lda $80
    and #7          ; keep the animation bits
    tax
    lda enemy_direction_chars_low,x
    sta $70
    lda enemy_direction_chars_high,x
    adc $71
    sta $71

    plot_characters_16x16:

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    lda $76
    and #1
    bne plot_characters_plot_16x16_1

    lda #5
    sta ($78),y
    jmp plot_characters_stored

    plot_characters_plot_16x16_1:
    clc
    lda #6
    sta ($78),y

    plot_characters_stored:

    iny
    lda $70
    sta ($78),y
    iny
    lda $71
    sta ($78),y
    iny
    lda $72
    sta ($78),y
    iny
    lda $73
    sta ($78),y

    clc
    lda $78
    adc #12
    sta $78

    plot_characters_loop_not_enemy:

    plot_characters_next:

    lda #255    ; terminate this stream of entries in the plot buffer
    ldy #0
    sta ($78),y
    clc
    rts

reset_plot_buffer:
    lda #$06    ; reset the index into the plot buffer
    sta $84
    lda #$52
    sta $85

    lda #255    ; terminate the plot list
    ldy #0
    sta ($84),y
    rts

reset_unplot_buffer:
    lda #$00    ; reset the index into the plot buffer
    sta $82
    lda #$52
    sta $83

    lda #255    ; terminate the unplot list
    ldy #0
    sta ($82),y
    rts

plot_buffer_types_low:  .byte <plot_buffer_loop_next, <plot8x24_y0, <plot8x24_y1, <plot8x8_y0, <plot8x8_y1, <plot16x16_y0, <plot16x16_y1
plot_buffer_types_high: .byte >plot_buffer_loop_next, >plot8x24_y0, >plot8x24_y1, >plot8x8_y0, >plot8x8_y1, >plot16x16_y0, >plot16x16_y1

plot_buffer:

    lda #$00
    sta $84
    lda #$52
    sta $85

    lda #6
    sta $88

    plot_buffer_loop:

        ldy #0
        lda ($84),y
        cmp #255
        beq plot_buffer_loop_skip

        clc
        tax
        lda plot_buffer_types_low,x
        sta $86
        lda plot_buffer_types_high,x
        sta $87

        iny
        lda ($84),y
        sta $70

        iny
        lda ($84),y
        sta $71

        iny
        lda ($84),y
        sta $72

        iny
        lda ($84),y
        sta $73

        jmp ($86)       ; returns to plot_buffer_loop_next

        plot_buffer_loop_skip:

        lda $88
        cmp #12
        beq plot_buffer_exit    ; both unplot and plot lists have terminated

        lda #12
        sta $88
        lda $84
        adc #6
        sta $84
        jmp plot_buffer_loop

        plot_buffer_loop_next:
        clc

        lda $84
        adc $88
        sta $84
        jmp plot_buffer_loop

    plot_buffer_exit:
    clc
    rts

room_row_offsets_low: .byte $9c,$a6,$b0,$ba,$c4,$ce,$d8,$e2,$ec,$f6

animate_player_left:

    ; Set the direction and toggle the animation bit.

    lda $3d01
    and #1
    eor #1      ; toggle animation flag
    sta $3d01   ; left (directional bits are 0)

    jsr plot_character
    rts

animate_player_right:

    ; Set the direction and toggle the animation bit.

    lda $3d01
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #2      ; right
    sta $3d01

    jsr plot_character
    rts

animate_player_up:

    ; Set the direction and toggle the animation bit.

    lda $3d01
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #4      ; up
    sta $3d01

    jsr plot_character
    rts

animate_player_down:

    ; Set the direction and toggle the animation bit.

    lda $3d01
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #6      ; down
    sta $3d01

    jsr plot_character
    rts

move_player:

    lda $3dfe
    and #1
    beq move_player_allowed

    clc
    rts

    move_player_allowed:

    lda #$00    ; set up the address of the player character
    sta $74
    lda #$3d
    sta $75

    ; Handle the left key.

    ldx #158            ; (Z)
    jsr check_key
    cpy #255
    bne move_player_not_left_key

    lda $3d05           ; read dx
    cmp #0
    beq move_player_left_check_x

    jsr unplot_character        ; unplot the player character
    dec $3d05
    clc
    jmp animate_player_left ; optimise away the rts
    
    move_player_left_check_x:   ; Check the x offset.

    lda $3d04
    cmp #0
    beq move_player_leave_room_left

    clc
    tay
    dey                         ; x - 1
    lda $3d02                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the left

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_left_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_left_exit:
    cmp #0
    bne move_player_not_left_key

    lda $3d03               ; dy
    cmp #0
    beq move_player_allow_left

    clc
    lda $70                 ; dy > 0 so we need to check another tile
    adc #10
    sta $70
    lda ($70),y             ; load the tile below and to the left

    cmp #0
    bne move_player_not_left_key

    move_player_allow_left:
    tya
    sta $81                 ; temporary
    jsr unplot_character    ; unplot the player character
    lda $81
    sta $3d04               ; store the new room x offset
    lda #3
    sta $3d05               ; dx = 3
    clc
    jmp animate_player_left ; optimise away the rts

    move_player_leave_room_left:
    sec
    lda $3df3
    sbc #1
    sta $3df3
    clc

    ; Set the player's position on the right of the screen.
    
    ; No need to unplot.

    lda #9      ; x = 9
    sta $3d04
    lda #2      ; dx = 2
    sta $3d05

    jsr animate_player_left
    sec                     ; indicate to the calling routine that the player
    rts                     ; has left the room

    move_player_not_left_key:

    ; Handle the right key.

    ldx #189            ; (X)
    jsr check_key
    cpy #255
    bne move_player_not_right_key

    lda $3d05                   ; read dx
    cmp #2
    beq move_player_right_check_x
    cmp #3
    beq move_player_right_tile

    jsr unplot_character        ; unplot the player character
    inc $3d05
    clc
    jmp animate_player_right    ; optimise away the rts
    
    move_player_right_check_x:  ; Check the x offset.

    lda $3d04
    cmp #9
    beq move_player_leave_room_right

    clc
    tay
    iny                         ; x + 1
    lda $3d02                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_right_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_right_exit:
    cmp #0
    bne move_player_not_right_key

    lda $3d03                   ; dy
    cmp #0
    beq move_player_allow_right

    clc                         ; dy > 0 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_player_not_right_key

    move_player_allow_right:

    jsr unplot_character        ; unplot the player character
    inc $3d05                   ; update dx
    clc
    jmp animate_player_right    ; optimise away the rts

    move_player_right_tile:

    jsr unplot_character    ; unplot the player character
    inc $3d04               ; store the new room x offset
    lda #0
    sta $3d05               ; dx = 0
    clc
    jmp animate_player_right ; optimise away the rts

    move_player_leave_room_right:
    clc
    lda $3df3
    adc #1
    sta $3df3
    clc

    ; Set the player's position on the left of the screen.

    ; No need to unplot.

    lda #0      ; x = 0
    sta $3d04
    lda #0      ; dx = 0
    sta $3d05

    jsr animate_player_right    
    sec                         ; indicate to the calling routine that the
    rts                         ; player has left the room

    move_player_not_right_key:

    ; Handle the up key.

    ldx #183            ; (:)
    jsr check_key
    cpy #255
    bne move_player_not_up_key

    lda $3d03           ; read dy
    cmp #0
    beq move_player_up_check_y

    jsr unplot_character        ; unplot the player character
    dec $3d03
    clc
    jmp animate_player_up       ; optimise away the rts
    
    move_player_up_check_y:     ; Check the y offset.

    lda $3d02
    cmp #0
    beq move_player_leave_room_up

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    lda $3d04                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_up_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_up_exit:
    cmp #0
    bne move_player_not_up_key

    lda $3d05                   ; dx
    cmp #3
    bmi move_player_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_player_not_up_key

    move_player_allow_up:
    txa
    sta $81                 ; temporary
    jsr unplot_character    ; unplot the player character
    lda $81
    sta $3d02               ; store the new room y offset
    lda #5
    sta $3d03               ; dy = 5
    clc
    jmp animate_player_up   ; optimise away the rts

    move_player_leave_room_up:
    sec
    lda $3df2
    sbc #1
    sta $3df2
    clc

    ; Set the player's position on the bottom of the screen.

    ; No need to unplot.

    lda #9      ; y = 9
    sta $3d02
    lda #0      ; dy = 0
    sta $3d03

    jsr animate_player_up
    sec                     ; indicate to the calling routine that the player
    rts                     ; has left the room

    move_player_not_up_key:

    ; Handle the down key.

    ldx #151            ; (/)
    jsr check_key
    cpy #255
    bne move_player_not_down_key

    lda $3d03                   ; read dy
    cmp #0
    beq move_player_down_check_y
    cmp #5
    beq move_player_down_tile

    jsr unplot_character        ; unplot the player character
    inc $3d03                   ; 0 < dy < 5
    clc
    jmp animate_player_down    ; optimise away the rts
    
    move_player_down_check_y:  ; Check the y offset.

    lda $3d02
    cmp #9
    beq move_player_leave_room_down

    clc
    tax
    inx                         ; y + 1
    lda $3d04                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_down_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_down_exit:
    cmp #0
    bne move_player_not_down_key

    lda $3d05                   ; dx
    cmp #3
    bmi move_player_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_player_not_down_key

    move_player_allow_down:

    jsr unplot_character        ; unplot the player character
    inc $3d03                   ; update dy
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_down_tile:

    jsr unplot_character        ; unplot the player character
    inc $3d02                   ; store the new room y offset
    lda #0
    sta $3d03                   ; dy = 0
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_leave_room_down:
    clc
    lda $3df2
    adc #1
    sta $3df2
    clc

    ; Set the player's position on the top of the screen.

    ; No need to unplot.

    lda #0      ; y = 0
    sta $3d02
    lda #0      ; dy = 0
    sta $3d03

    jsr animate_player_down
    sec                         ; indicate to the calling routine that the
    rts                         ; player has left the room

    move_player_not_down_key:
    clc
    rts

try_to_exit_level:

    lda $3df0                   ; set the exit flag
    ora #$80
    sta $3df0
    sec                         ; indicate that the player is leaving the room
    rts

check_fire_key:

    lda $3dfd
    bne check_fire_key_exit

    ldx #182            ; (Return)
    jsr check_key
    cpy #255
    bne check_fire_key_exit

    lda $3d06
    cmp #0
    bne check_fire_key_exit

    lda #15
    sta $3dfd

    jmp create_projectile   ; optimise away the rts

    check_fire_key_exit:
    clc
    rts

create_projectile:

    lda #2
    sta $3d06

    lda $3d01
    and #$06        ; copy the direction information
    asl
    asl
    asl
    ora $3df9       ; apply the projectile type
    sta $3d07

    lda $3d03       ; dy
    cmp #4
    bpl create_projectile_below

    clc
    adc #2
    sta $3d09       ; dy + 2
    lda $3d02       ; y
    sta $3d08
    jmp create_projectile_continue

    create_projectile_below:
    sec
    sbc #4
    sta $3d09       ; dy - 4
    clc
    lda $3d02       ; y
    adc #1
    sta $3d08

    create_projectile_continue:
    lda $3d04       ; x
    sta $3d0a

    lda $3d05       ; dx
    sta $3d0b

    lda #$06
    sta $74
    lda #$3d
    sta $75
    jsr plot_character

    clc
    rts

emerge_type:                    ; returns A=type
    jsr unlimited_values
    lda $7d
    and #7
    cmp #4
    bmi emerge_type_ok

    sec
    sbc #4
    clc

    emerge_type_ok:
    cmp $3df1               ; only allow the appropriate enemies for this level
    bmi emerge_type_exit

    sec
    sbc $3df1
    clc

    emerge_type_exit:
    asl
    asl
    asl
    asl
    clc
    rts

emerge_x_position:              ; returns A=position

    jsr unlimited_values
    lda $3d04
    jmp emerge_position_common

emerge_y_position:              ; returns A=position

    jsr unlimited_values
    lda $3d02
    ; run on into the next routine

emerge_position_common:

    cmp #3
    bpl emerge_position_common_not_first_area

    lda $7d
    and #7
    cmp #6
    bpl emerge_position_common_first_area_truncate

    adc #4
    rts

    emerge_position_common_first_area_truncate:
    clc
    lda #8
    rts

    emerge_position_common_not_first_area:
    cmp #7
    bpl emerge_position_common_third_area

    lda $7d
    cmp #5
    bmi emerge_position_common_lower_second_area

    clc
    lda $7d
    and #3
    adc #6
    rts

    emerge_position_common_lower_second_area:
    clc

    lda $7d
    and #3
    rts

    emerge_position_common_third_area:
    clc

    lda $7d
    and #7
    cmp #6
    bpl emerge_position_common_third_area_truncate

    rts

    emerge_position_common_third_area_truncate:
    clc
    lda #5
    rts

emerge_character:           ; $74,$75=character address

    lda #63
    sta $3dff

    lda #3      ; try three tiles to find a space
    sta $81
    emerge_character_loop:

        jsr emerge_y_position     ; obtain a y position
        tax
        jsr emerge_x_position     ; obtain an x position
        sta $80                 ; temporary
        tay

        lda room_row_offsets_low,x
        sta $70
        lda #$57
        sta $71
        lda ($70),y             ; load the tile

        cmp #0
        beq emerge_character_space_found

        dec $81
        bpl emerge_character_loop

    bne emerge_character_exit

    emerge_character_space_found:
    ; There is a space in the room, so add an emerging enemy.

    ldy #0
    lda #3
    sta ($74),y

    jsr emerge_type         ; obtain an enemy type
    iny
    sta ($74),y

    txa
    iny
    sta ($74),y             ; store the y position
    lda #1
    iny
    sta ($74),y             ; store the dy offset

    lda $80
    iny
    sta ($74),y             ; store the x position
    lda #0
    iny
    sta ($74),y             ; store the dx offset

    jsr plot_character

    emerge_character_exit:
    clc
    rts

emerge_explode:             ; $74,$75=character address

    jsr unplot_character

    ldy #1
    lda ($74),y     ; direction/animation
    tax
    adc #1          ; update the counter
    and #3          ; mask off everything else
    sta $80         ; store the masked counter value
    bne move_characters_explosion_not_finished

    txa
    and #8
    bne move_characters_remove_character

    ; For emerges, convert into an enemy.
    txa
    and #$70        ; only keep bits 4,5,6
    ora #8          ; make this an enemy

    ldy #0
    sta ($74),y     ; update the type
    iny
    lda #0          ; prepare the direction and animation offset
    sta ($74),y

    jsr plot_character
    jmp emerge_explode_exit

    move_characters_remove_character:

    ; For finished explosions, just write 0 into the character array.
    lda #0
    ldy #0
    sta ($74),y
    jmp emerge_explode_exit

    move_characters_explosion_not_finished:
    txa
    and #$f8
    ora $80

    ldy #1
    sta ($74),y

    jsr plot_character

    emerge_explode_exit:
    clc
    rts

animate_enemy_left:     ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    and #$0b    ; keep vertical direction bit and animation bits
    sta ($74),y ; left (horizontal directional bit is 0)

    rts

move_enemy_left:        ; $74,$75=character address

    ldy #5
    lda ($74),y         ; read dx
    cmp #0
    beq move_enemy_left_check_x

    sec
    sbc #1
    ldy #5
    sta ($74),y                 ; dx
    clc
    jmp animate_enemy_left      ; optimise away the rts

    move_enemy_left_check_x:

    ; Check the x offset.

    ldy #4
    lda ($74),y                 ; x
    cmp #0
    beq move_enemy_left_exit

    sec
    sbc #1                      ; x - 1
    sta $81                     ; temporary
    ldy #2
    lda ($74),y                 ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    ldy $81                     ; temporary (x - 1)
    lda ($70),y                 ; load the tile to the left

    cmp #0
    bne move_enemy_left_exit

    ldy #3
    lda ($74),y                 ; dy
    cmp #3
    bmi move_enemy_allow_left

    clc
    lda $70                 ; dy > 2 so we need to check another tile
    adc #10
    sta $70
    ldy $81                 ; temporary (x - 1)
    lda ($70),y             ; load the tile below and to the left

    cmp #0
    bne move_enemy_left_exit

    move_enemy_allow_left:
    lda $81
    ldy #4
    sta ($74),y             ; store the new room x offset
    lda #3
    ldy #5
    sta ($74),y             ; dx = 3
    clc
    jmp animate_enemy_left ; optimise away the rts

    move_enemy_left_exit:
    sec
    rts

animate_enemy_right:    ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    ora #$04    ; right (keep vertical direction bit and animation bits)
    sta ($74),y

    rts

move_enemy_right:       ; $74,$75=character_address

    ldy #5
    lda ($74),y                 ; read dx
    cmp #0
    beq move_enemy_right_check_x
    cmp #3
    beq move_enemy_right_tile

    clc
    adc #1
    ldy #5
    sta ($74),y
    jmp animate_enemy_right    ; optimise away the rts
    
    move_enemy_right_check_x:  ; Check the x offset.

    ldy #4
    lda ($74),y                 ; x
    cmp #9
    beq move_enemy_right_exit

    clc
    adc #1                      ; x + 1
    sta $81                     ; temporary (x + 1)
    ldy #2
    lda ($74),y                 ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    ldy $81                     ; temporary (x + 1)
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_enemy_right_exit

    ldy #3
    lda ($74),y                 ; dy
    cmp #3
    bmi move_enemy_allow_right

    clc                         ; dy > 2 so we need to check another tile
    lda $70
    adc #10
    sta $70
    ldy $81                     ; temporary (x + 1)
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_enemy_right_exit

    move_enemy_allow_right:
    clc

    ldy #5
    lda ($74),y                 ; dx
    adc #1
    sta ($74),y                 ; update dx
    clc
    jmp animate_enemy_right    ; optimise away the rts

    move_enemy_right_tile:
    clc

    ldy #4
    lda ($74),y             ; x
    adc #1
    sta ($74),y             ; store the new room x offset
    lda #0
    iny
    sta ($74),y             ; dx = 0
    clc
    jmp animate_enemy_right ; optimise away the rts

    move_enemy_right_exit:
    sec
    rts

animate_enemy_up:   ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    and #$07    ; keep horizontal direction bit and animation bits
    sta ($74),y

    rts

move_enemy_up:      ; $74,$75=character address

    ldy #3
    lda ($74),y                 ; read dy
    cmp #0
    beq move_enemy_up_check_y

    sec
    sbc #1
    ldy #3
    sta ($74),y                 ; dy
    clc
    jmp animate_enemy_up        ; optimise away the rts
    
    move_enemy_up_check_y:

    ; Check the y offset.

    ldy #2
    lda ($74),y                 ; y
    cmp #0
    beq move_enemy_up_exit

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    ldy #4
    lda ($74),y                 ; load the x offset
    sta $81                     ; temporary (x)
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_enemy_up_exit

    ldy #5
    lda ($74),y                 ; dx
    cmp #0
    beq move_enemy_allow_up

    clc                     ; dx != 0 so we need to check another tile
    ldy $81
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_enemy_up_exit

    move_enemy_allow_up:
    txa
    ldy #2
    sta ($74),y             ; store the new room y offset
    lda #5
    iny
    sta ($74),y             ; dy = 5
    clc
    jmp animate_enemy_up   ; optimise away the rts

    move_enemy_up_exit:
    sec
    rts

animate_enemy_down: ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    ora #$08    ; down
    sta ($74),y

    rts

move_enemy_down:    ; $74,$75=character address    

    ldy #3
    lda ($74),y         ; dy
    cmp #2
    beq move_enemy_down_check_y
    cmp #5
    beq move_enemy_down_tile

    adc #1
    ldy #3
    sta ($74),y         ; dy
    clc
    jmp animate_enemy_down      ; optimise away the rts
    
    move_enemy_down_check_y:

    ; Check the y offset.

    ldy #2
    lda ($74),y
    cmp #9
    beq move_enemy_down_exit

    clc
    adc #1                      ; y + 1
    tax
    ldy #4
    lda ($74),y                 ; load the x offset
    sta $81                     ; temporary
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_enemy_down_exit

    ldy #5
    lda ($74),y                 ; dx
    cmp #0
    beq move_enemy_allow_down

    clc                         ; dx != 0 so we need to check another tile
    ldy $81                     ; x
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_enemy_down_exit

    move_enemy_allow_down:
    clc

    ldy #3
    lda ($74),y                 ; dy
    adc #1
    sta ($74),y                 ; update dy
    clc
    jmp animate_enemy_down      ; optimise away the rts

    move_enemy_down_tile:
    clc

    ldy #2
    lda ($74),y                 ; y
    adc #1
    sta ($74),y                 ; store the new room y offset
    lda #0
    iny
    sta ($74),y                 ; dy = 0
    clc
    jmp animate_enemy_down      ; optimise away the rts

    move_enemy_down_exit:
    sec
    rts

move_enemy_animate:     ; $74,$75=character address

    ldy #1
    lda ($74),y         ; direction/animation
    sta $81
    adc #1
    and #$03            ; keep animation bits
    sta $8f
    lda $81
    and #$0c            ; mask off the animation bits
    ora $8f
    sta ($74),y
    rts

move_enemy:             ; $74,$75=character address

    lda #0
    sta $8d
    lda #0
    sta $8e

    ldy #2
    lda ($74),y         ; y
    cmp $3d02           ; player y
    bmi move_enemy_downwards
    bne move_enemy_upwards

    ldy #3
    lda ($74),y         ; dy
    cmp $3d03           ; player y
    beq move_enemy_horizontally
    bpl move_enemy_upwards

    move_enemy_downwards:
    lda #2
    sta $8d
    jmp move_enemy_horizontally

    move_enemy_upwards:
    lda #1
    sta $8d
    ;jmp move_enemy_horizontally

    move_enemy_horizontally:
    ldy #4
    lda ($74),y         ; x
    cmp $3d04           ; player x
    bmi move_enemy_rightwards
    bne move_enemy_leftwards

    ldy #5
    lda ($74),y         ; dx
    cmp #0
    beq move_enemy_with_direction
    bpl move_enemy_leftwards

    move_enemy_rightwards:
    lda #2
    sta $8e
    jmp move_enemy_with_direction

    move_enemy_leftwards:
    lda #1
    sta $8e

    move_enemy_with_direction:
    clc

    jsr unplot_character

    lda $8e
    cmp #1
    bne move_enemy_not_left
    jsr move_enemy_left
    clc
    jmp move_enemy_not_right

    move_enemy_not_left:
    lda $8e
    cmp #2
    bne move_enemy_not_right
    jsr move_enemy_right
    clc

    move_enemy_not_right:
    lda $8d
    cmp #1
    bne move_enemy_not_up
    jsr move_enemy_up
    clc
    jmp move_enemy_toggle

    move_enemy_not_up:
    lda $8d
    cmp #2
    bne move_enemy_toggle
    jsr move_enemy_down

    move_enemy_toggle:
    clc
    jsr move_enemy_animate
    jmp plot_character      ; optimise away the rts

    move_enemy_exit:
    clc
    rts

create_explosion:           ; X=y, Y=x

    lda #3
    sta $3d24
    lda #8
    sta $3d25
    txa
    sta $3d26
    lda #1
    sta $3d27
    tya
    sta $3d28
    lda #0
    sta $3d29
    rts

move_projectile_left:

    lda $3d0b
    cmp #0
    beq move_projectile_left_check_x

    dec $3d0b
    clc
    rts

    move_projectile_left_check_x:

    lda $3d0a
    cmp #0
    beq move_projectile_left_exit

    tay
    dey                         ; x - 1
    ldx $3d08                   ; y
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the left

    cmp #0
    bne move_projectile_left_wall

    lda $3d09                   ; dy
    cmp #5
    bmi move_projectile_allow_left

    clc                         ; dy > 4 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the left

    cmp #0
    bne move_projectile_left_wall

    move_projectile_allow_left:

    sty $3d0a       ; x
    lda #3
    sta $3d0b       ; dx = 3

    clc
    rts

    move_projectile_left_wall:  ; the projectile hit a wall
    clc

    lda $3d07                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_left

    cmp #2
    bne move_projectile_left_not_boomerang

    lda $3d07
    and #$0f
    cmp #8
    bpl move_projectile_left_exit

    ldx $3d09       ; dy
    ora boomerang_horizontal,x
    sta $3d07
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_left_not_boomerang:

    cmp #6                          ; type 3 can destroy certain walls
    bne move_projectile_left_exit

    lda $3d09                       ; dy
    cmp #5
    beq move_projectile_left_exit   ; shots must be lined up
    
    lda ($70),y                 ; load the tile to the left
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_left_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$24
    sta $74
    lda #$3d
    sta $75
    jsr plot_character

    move_projectile_left_exit:
    sec
    rts

boomerang_horizontal: .byte $28, $28, $28, $38, $38, $38

move_projectile_right:

    ; Fire right.

    lda $3d0b
    cmp #2
    beq move_projectile_right_check_x
    cmp #3
    beq move_projectile_right_tile

    inc $3d0b
    clc
    rts

    move_projectile_right_check_x:

    lda $3d0a       ; x
    cmp #9
    bne move_projectile_right_not_edge
    jmp move_projectile_right_exit

    move_projectile_right_not_edge:
    clc
    tay
    iny                         ; x + 1
    ldx $3d08                   ; y
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_projectile_right_wall

    lda $3d09                   ; dy
    cmp #5
    bmi move_projectile_allow_right

    clc                         ; dy > 4 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_projectile_right_wall

    move_projectile_allow_right:

    inc $3d0b       ; dx
    clc
    rts

    move_projectile_right_tile:

    inc $3d0a       ; x
    lda #0
    sta $3d0b       ; dx
    clc
    rts

    move_projectile_right_wall:  ; the projectile hit a wall
    clc

    lda $3d07                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_right

    cmp #2
    bne move_projectile_right_not_boomerang

    lda $3d07
    and #$0f
    cmp #8
    bpl move_projectile_right_exit

    ldx $3d09       ; dy
    ora boomerang_horizontal,x
    sta $3d07
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_right_not_boomerang:

    cmp #6                      ; type 3 can destroy certain walls
    bne move_projectile_right_exit

    lda $3d09                   ; dy
    cmp #5
    beq move_projectile_right_exit  ; shots must be lined up
    
    lda ($70),y                 ; load the tile to the right
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_right_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$24
    sta $74
    lda #$3d
    sta $75
    jsr plot_character

    move_projectile_right_exit:
    sec
    rts

move_projectile_up:

    lda $3d09           ; read dy
    cmp #0
    beq move_projectile_up_check_y

    dec $3d09
    clc
    rts
    
    move_projectile_up_check_y:     ; Check the y offset.

    lda $3d08
    cmp #0
    beq move_projectile_up_exit

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    lda $3d0a                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_projectile_up_wall

    lda $3d0b                   ; dx
    cmp #3
    bmi move_projectile_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_projectile_up_wall

    move_projectile_allow_up:
    txa
    sta $3d08               ; store the new room y offset
    lda #5
    sta $3d09               ; dy = 5

    clc
    rts

    move_projectile_up_wall:    ; the projectile hit a wall
    clc

    lda $3d07                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_up

    cmp #2
    bne move_projectile_up_not_boomerang

    lda $3d07
    and #$0f
    cmp #8
    bpl move_projectile_up_exit

    ldx $3d0b       ; dx
    ora boomerang_vertical,x
    sta $3d07
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_up_not_boomerang:

    cmp #6                      ; type 3 can destroy certain walls
    bne move_projectile_up_exit

    lda $3d0b                   ; dx
    cmp #3
    bpl move_projectile_up_exit ; shots must be lined up
    
    lda ($70),y                 ; load the tile above
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_up_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$24
    sta $74
    lda #$3d
    sta $75
    jsr plot_character

    move_projectile_up_exit:
    sec
    rts

boomerang_vertical: .byte $08, $08, $18, $18

move_projectile_down:

    lda $3d09                   ; read dy
    cmp #4
    beq move_projectile_down_check_y
    cmp #5
    beq move_projectile_down_tile

    inc $3d09                   ; 0 < dy < 5
    clc
    rts
    
    move_projectile_down_check_y:  ; Check the y offset.

    lda $3d08
    cmp #9
    beq move_projectile_down_exit

    clc
    tax
    inx                         ; y + 1
    lda $3d0a                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_projectile_down_wall

    lda $3d0b                   ; dx
    cmp #3
    bmi move_projectile_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_projectile_down_wall

    move_projectile_allow_down:

    inc $3d09                   ; update dy
    clc
    rts

    move_projectile_down_tile:

    inc $3d08                   ; store the new room y offset
    lda #0
    sta $3d09                   ; dy = 0
    clc
    rts

    move_projectile_down_wall:  ; the projectile hit a wall
    clc

    lda $3d07                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_down

    cmp #2
    bne move_projectile_down_not_boomerang

    lda $3d07
    and #$0f
    cmp #8
    bpl move_projectile_down_exit

    ldx $3d0b       ; dx
    ora boomerang_vertical,x
    sta $3d07
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_down_not_boomerang:

    cmp #6                      ; type 3 can destroy certain walls
    bne move_projectile_down_exit

    lda $3d0b                   ; dx
    cmp #3
    bpl move_projectile_down_exit   ; shots must be lined up
    
    lda ($70),y                 ; load the tile below
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_down_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$24
    sta $74
    lda #$3d
    sta $75
    jsr plot_character

    move_projectile_down_exit:
    sec
    rts

move_projectile_animate:

    lda $3d07
    eor #1
    sta $3d07
    rts

move_projectile:

    lda $3d06
    cmp #0
    bne move_projectile_move
    jmp move_projectile_exit

    move_projectile_move:
    clc

    lda #$06
    sta $74
    lda #$3d
    sta $75
    jsr unplot_character

    lda $3d07
    and #$30            ; direction

    cmp #0
    bne move_projectile_not_left

    jsr move_projectile_left
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_left:
    cmp #$10
    bne move_projectile_not_right

    jsr move_projectile_right
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_right:
    cmp #$20
    bne move_projectile_not_up

    jsr move_projectile_up
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_up:
    cmp #$30
    bne move_projectile_toggle

    jsr move_projectile_down
    bcs move_projectile_destroy

    move_projectile_toggle:

    jsr projectile_collide
    bcs move_projectile_destroy

    jsr move_projectile_animate

    lda #$06
    sta $74
    lda #$3d
    sta $75
    jmp plot_character          ; optimise away the rts

    move_projectile_destroy:
    clc

    ldy #0
    lda ($74),y ; type
    cmp #8
    bmi move_projectile_no_enemy_collision

    and #$70            ; increase the player's score
    lsr
    lsr
    lsr
    lsr
    tax
    lda enemy_scores,x
    sta $70
    jsr add_score

    ; Unplot the enemy and replace it with an explosion.

    jsr unplot_character

    lda #3      ; explosion
    ldy #0
    sta ($74),y

    lda #8
    ldy #1
    sta ($74),y

    jsr plot_character

    move_projectile_no_enemy_collision:

    lda $3d07       ; type 2 projectiles pass through everything
    and #$06
    cmp #4
    bne move_projectile_remove_projectile

    ; Ideally, we would have recorded if the projectile left the screen so
    ; that we don't perform these checks again here, but it would just add
    ; overhead to the normal movement routines for the other weapons.

    lda $3d08       ; y
    cmp #0
    beq move_projectile_remove_projectile
    cmp #9
    beq move_projectile_remove_projectile

    lda $3d0a       ; x
    cmp #0
    beq move_projectile_remove_projectile
    cmp #9
    beq move_projectile_remove_projectile

    clc
    lda #$06
    sta $74
    lda #$3d
    sta $75

    jsr plot_character
    jmp move_projectile_exit

    move_projectile_remove_projectile:

    lda #0                      ; remove the projectile from the character list
    sta $3d06

    move_projectile_exit:
    clc
    rts

enemy_scores: .byte 2, 4, 6, 8, 10

move_characters:

    lda #$0c            ; set the character address
    sta $74
    lda #$3d
    sta $75

    move_characters_loop:

        ldy #0
        lda ($74),y
        cmp #0
        bne move_characters_read_character

        lda $74
        cmp #$24
        bpl move_characters_read_character

        ; See if it is time to generate a new enemy.
        lda $3dff
        cmp #0
        bne move_characters_next

        lda $3df0           ; player demise - no more enemies
        and #$40
        bne move_characters_next

        jsr emerge_character
        jmp move_characters_next

        move_characters_read_character:
        clc

        move_characters_not_projectile:
        cmp #3
        bne move_characters_not_emerge_explode

        lda $3dfe           ; check motion counter
        and #3
        bne move_characters_next

        jsr emerge_explode
        jmp move_characters_next

        move_characters_not_emerge_explode:
        cmp #8
        bmi move_characters_next

        lda $3dfe           ; check motion counter
        and #3
        bne move_characters_next

        lda $3df0           ; player demise - no enemy motion
        and #$40
        bne move_characters_next

        jsr move_enemy

        move_characters_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$2a
        bpl move_characters_endloop
        sta $74
        jmp move_characters_loop

    move_characters_endloop:

    ; Check collisions with the player.

    jsr player_collide
    bcc move_characters_exit
    clc

    ldy #0
    lda ($74),y ; type
    cmp #8
    bpl move_character_destroy_enemy

    ; Unplot the item.
    jsr unplot_character

    ; Remove it from the item table.
    ldx $3df2
    lda eleven_times_table,x
    adc $3df3
    tax
    lda #0
    sta $5100,x

    lda #0      ; remove the item from the character list
    ldy #0
    sta ($74),y

    iny
    lda ($74),y         ; get the item type

    sta $8d             ; temporarily store A and increase the score
    tax
    lda item_scores,x
    sta $70
    jsr add_score
    lda $8d

    ; Check the item type.
    cmp #8
    bmi move_characters_not_health

    lda #12
    sta $70
    jsr add_strength
    clc
    rts

    move_characters_not_health:
    cmp #5
    bmi move_characters_not_treasure

    ; Do nothing here. We have already increased the player's score.
    clc
    rts

    move_characters_not_treasure:
    cmp #4
    bmi move_characters_not_key

    ; Key - update the item/player flags byte.
    lda $3df0
    ora #$01
    sta $3df0
    clc
    rts

    move_characters_not_key:

    ; Update the player's weapon.
    asl
    sta $3df9
    clc
    rts

    move_character_destroy_enemy:
    
    ; Unplot the enemy and replace it with an explosion.

    jsr unplot_character

    lda #3      ; explosion
    ldy #0
    sta ($74),y

    lda #8
    ldy #1
    sta ($74),y

    jsr plot_character

    ; Reduce the player's strength.

    lda #1
    sta $70
    jmp reduce_strength ; optimise away the rts

    move_characters_exit:
    clc
    rts

item_scores:     .byte $1,$4,$9,$16, $50,$20,$5,$10,$40
score_vdu_bytes: .byte 1,1,31   ; reversed
score_digits:    .byte "0123456789"

add_score:      ; $70=score to add

    sed
    lda $3df6
    adc $70
    sta $3df6
    lda $3df7
    adc #0
    sta $3df7
    lda $3df8
    adc #0
    sta $3df8
    cld

write_score:

    ldx #2
    write_score_vdu_bytes:
        lda score_vdu_bytes,x
        jsr $ffee
        dex
        bpl write_score_vdu_bytes

    lda #$f6
    sta $70
    lda #$3d
    sta $71

    ldy #2
    write_score_loop:

        lda ($70),y
        lsr
        lsr
        lsr
        lsr
        tax
        lda score_digits,x
        jsr $ffee

        lda ($70),y
        and #$0f
        tax
        lda score_digits,x
        jsr $ffee

        dey
        bpl write_score_loop

    clc
    rts

strength_units: .byte $00,$88,$cc,$ee

add_strength:   ; $70=strength to add

    ; Divide the initial strength by 4 to determine which half character to
    ; start plotting at, and multiply by 8 to get the address. The net result
    ; is to mask off the bottom two bits and shift left once.
    lda $3df4
    and #$fc
    asl
    clc
    tay

    lda $3df4
    adc $70
    cmp #65
    bmi add_strength_update

    lda #64
    sec
    sbc $3df4
    sta $70
    lda #64

    add_strength_update:
    clc
    sta $3df4

    ldx $70

    lda #$f3    ; the start of the strength bar
    sta $70
    lda #$59
    sta $71

    add_strength_loop:

        cpx #4
        bmi add_strength_loop_extra

        clc
        lda #$ff
        sta ($70),y

        tya
        adc #8
        tay

        txa
        sec
        sbc #4
        clc
        tax

        cmp #4
        bpl add_strength_loop

    add_strength_loop_extra:

    ; For any remaining units in excess of the multiples of four units, plot
    ; the appropriate byte.

    lda strength_units,x
    sta ($70),y

    clc
    rts

reduce_strength:    ; $70=strength to remove

    lda $3df4
    tax
    sec
    sbc $70
    bpl reduce_strength_update

    lda #0

    reduce_strength_update:
    clc
    sta $3df4

    ; Divide the final strength by 4 to determine which half character to
    ; plot, and multiply by 8 to get the address. The net result is to mask off
    ; the bottom two bits and shift left once.
    and #$fc
    asl
    tay

    lda #$f3    ; the start of the strength bar
    sta $70
    lda #$59
    sta $71

    lda $3df4
    and #3
    tax
    lda strength_units,x
    sta ($70),y

    lda $3df4
    cmp #0
    bne reduce_strength_exit

    lda $3df0       ; the player ran out of strength
    ora #$40
    sta $3df0

    lda #64         ; reset the delay counter
    sta $3df5

    lda #$00        ; unplot the player
    sta $74
    lda #$3d
    sta $75

    jsr unplot_character

    lda #8          ; change the player's direction to the demise animation
    sta $3d01

    jsr plot_character

    lda #$0c
    sta $74

    reduce_strength_destroy_enemies_loop:

        ldy #0
        lda ($74),y
        cmp #8
        bmi reduce_strength_not_enemy

        jsr unplot_character

        lda #3          ; emerge/explosion
        ldy #0
        sta ($74),y

        iny
        lda #8          ; explosion
        sta ($74),y

        jsr plot_character

        reduce_strength_not_enemy:
        clc
        lda $74
        adc #6
        sta $74
        cmp #$24
        bmi reduce_strength_destroy_enemies_loop

    reduce_strength_exit:
    clc
    rts

remove_characters:

    ; Clear the character table.

    ldx #6
    remove_characters_loop:
        lda #0
        sta $3d00,x
        txa
        adc #6
        tax
        cpx #$2a
        bmi remove_characters_loop

    rts

; The player collision masks use bits to represent where the player is in a
; tile.

; Player is above, enemy is below, checking the overlap in the lower tile.
player_collision_mask_above: .byte $00, $20, $30, $38, $3c, $3e

projectile_collision_mask_above: .byte $00, $00, $00, $00, $00, $20

; Player and enemy share the same tile or player is on the tile below.
player_collision_mask_below:  .byte $3f, $1f, $0f, $07, $03, $01

projectile_collision_mask_below: .byte $30, $18, $0c, $06, $03, $01

; Player is above or on the same tile, enemy is below, checking the overlap in
; the lower tile.
enemy_collision_mask_above:  .byte $3c, $1e, $0f, $07, $03, $01

; Enemy is above, player is below, checking the overlap in the lower tile.
enemy_collision_mask_below: .byte $00, $00, $00, $20, $30, $38

; Player is to the left, enemy is to the right, checking the overlap in the
; right hand tile.
player_collision_mask_left:
projectile_collision_mask_left: .byte $00, $00, $00, $08

; Player and enemy share the same tile or player is on the tile to the right.
player_collision_mask_right:
projectile_collision_mask_right: .byte $0c, $06, $03, $01

; Player is to the left, enemy is to the right or on the same tile, checking
; the overlap in the right hand tile.
enemy_collision_mask_left:  .byte $0f, $07, $03, $01

; Enemy is to the left, player is to the right, checking the overlap in the
; right hand tile.
enemy_collision_mask_right: .byte $00, $08, $0c, $0e

player_collide:

    lda $3d02                           ; player y
    sta $8a
    lda $3d04                           ; player x
    sta $8b

    ldx $3d03                           ; player dy
    lda player_collision_mask_above,x
    sta $86
    lda player_collision_mask_below,x
    sta $88
    ldx $3d05                           ; player dx
    lda player_collision_mask_left,x
    sta $87
    lda player_collision_mask_right,x
    sta $89

    jmp collide ; optimise away the rts

projectile_collide:

    lda $3d08                           ; projectile y
    sta $8a
    lda $3d0a                           ; projectile x
    sta $8b

    ldx $3d09                           ; projectile dy
    lda projectile_collision_mask_above,x
    sta $86
    lda projectile_collision_mask_below,x
    sta $88
    ldx $3d0b                           ; projectile dx
    lda projectile_collision_mask_left,x
    sta $87
    lda projectile_collision_mask_right,x
    sta $89

    jmp collide ; optimise away the rts

collide:

    lda #$0c            ; set the character address
    sta $74
    lda #$3d
    sta $75

    collide_loop:

        ldy #0
        lda ($74),y         ; type
        cmp #4
        bpl collide_check

        jmp collide_next

        collide_check:

        ldy #2
        lda ($74),y         ; y
        sec
        sbc $8a             ; y - player/projectile y
        beq check_collide_y_equal
        cmp #1
        beq check_collide_y_greater
        cmp #255
        beq check_collide_y_less

        jmp collide_next

        check_collide_y_equal:
        ; The enemy is on the same tile as the player/projectile so look at the
        ; collision on their common tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_above,x
        and $88                             ; player/projectile mask below
        bne check_collide_x

        jmp collide_next

        check_collide_y_greater:
        ; The enemy is on the tile below the player/projectile so look at the
        ; collision on the enemy's tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_above,x
        and $86                             ; player mask above
        bne check_collide_x

        jmp collide_next

        check_collide_y_less:
        ; The enemy is on the tile above the player/projectile so look at the
        ; collision on the player's tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_below,x
        and $88                             ; player mask below
        bne check_collide_x

        jmp collide_next

        check_collide_x:
        ldy #4
        lda ($74),y         ; x
        sec
        sbc $8b             ; x - player/projectile x
        beq check_collide_x_equal
        cmp #1
        beq check_collide_x_greater
        cmp #255
        beq check_collide_x_less

        jmp collide_next

        check_collide_x_equal:
        ; The enemy is on the same tile as the player/projectile so look at the
        ; collision on their common tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_left,x
        and $89                             ; player mask right
        bne check_collide_destroy

        jmp collide_next

        check_collide_x_greater:
        ; The enemy is the tile to the right of the player/projectile so look
        ; at the collision on the enemy's tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_left,x
        and $87                             ; player mask left
        bne check_collide_destroy

        jmp collide_next

        check_collide_x_less:
        ; The enemy is the tile to the left of the player/projectile so look at
        ; the collision on the player's tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_right,x
        and $89                             ; player mask right
        bne check_collide_destroy

        collide_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$24
        bpl collide_exit
        sta $74
        jmp collide_loop

    check_collide_destroy:

    sec         ; set the carry flag to inform the caller that the
    rts         ; player/projectile should be destroyed

    collide_exit:
    clc
    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $3dfb
    lda $71
    sta $3dfc
    lda #0
    sta $3dfd
    sta $3dfe
    sta $3dff

    lda #$c         
    ldx #$fb
    ldy #$3d
    jsr $fff1
    rts

blank_screen:
    lda #1
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #2
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #3
    sta $70
    lda #0
    sta $71
    jsr set_palette
    rts

sprites_file_name: .byte "SPRITES", 13
chars_file_name: .byte "CHARS", 13

sprites_block: .byte <sprites_file_name, >sprites_file_name
               .byte 0, $53, 0, 0
               .byte 0, $53, 0, 0
               .byte $60, $03, 0, 0
               .byte $60, $56, 0, 0

chars_block: .byte <chars_file_name, >chars_file_name
               .byte $00, $3e, 0, 0
               .byte $00, $3e, 0, 0
               .byte $80, $12, 0, 0
               .byte $80, $50, 0, 0

init:
    lda #255
    ldx #<sprites_block
    ldy #>sprites_block
    jsr $ffdd

    lda #255
    ldx #<chars_block
    ldy #>chars_block
    jsr $ffdd

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop

    rts

title_vdu_bytes: .byte 12, 17,2, 31,4,27, "Press SPACE", 31,7,28, "to play"

show_title:

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    ldx #0
    write_title_text_loop:
        lda title_vdu_bytes,x
        jsr $ffee
        inx
        cpx #27
        bmi write_title_text_loop

    rts

game_over_vdu_bytes: .byte 31,4,14, 17,2, "The journey", 31,6,15, "is over"

show_game_over:

    ldx #0
    write_game_over_text_loop:
        lda game_over_vdu_bytes,x
        jsr $ffee
        inx
        cpx #26
        bmi write_game_over_text_loop

    lda #192
    sta $3df5
    show_game_over_delay_loop:

        lda #19
        jsr $fff4
        dec $3df5
        bne show_game_over_delay_loop

    rts

status_vdu_bytes: .byte 31,2,0, 17,3, "Score", 31,11,0, 17,2, "Strength", 17,1
; TAB(1,0), COLOUR 3, "Score", TAB(12,0), COLOUR 2, "Strength", COLOUR 1

start_new_game:

    ; Clear the screen.
    lda #12
    jsr $ffee

    ; Blank the screen now because it will be blanked before the room is shown
    ; and otherwise the text will show briefly.
    jsr blank_screen

    ; Write the status text.
    ldx #0
    write_status_text_loop:
        lda status_vdu_bytes,x
        jsr $ffee
        inx
        cpx #25
        bmi write_status_text_loop

    ; Set the level.
    lda #0
    sta $3dfa

    ; Set the score.
    lda #0
    sta $3df6
    sta $3df7
    sta $3df8
    jsr write_score

    ; Set the player's strength.
    lda #64
    sta $70
    jsr add_strength

    ; Set the projectile type.
    lda #0
    sta $3df9

    rts

start_level:

    ; Clear the item/player flags.
    lda #0
    sta $3df0

    ; Add to the player's strength.
    lda #20
    sta $70
    jsr add_strength

    ; Set current room.

    ldx $3dfa
    lda start_rooms_y,x
    sta $3df2
    lda start_rooms_x,x
    sta $3df3

    ; Set the player position.

    lda #1      ; player
    sta $3d00
    lda #6      ; down (first frame)
    sta $3d01
    lda #5      ; y=5
    sta $3d02
    lda #0      ; dy=0
    sta $3d03
    lda #5      ; x=5
    sta $3d04
    lda #0      ; dx=0
    sta $3d05

    ; Fill the treasure table with objects.
    lda $3dfa   ; level
    tax
    lda key_rooms,x
    sta $80
    
    ldx $3dfa   ; level
    lda seeds,x
    adc #1
    and #31
    sta $7c
    clc
    lda seeds,x
    adc #2
    and #31
    sta $7d
    clc

    lda $3dfa   ; create an upper limit on the weapon type found in this level
    adc #2
    sta $3df1
    clc

    lda #$00
    sta $8e
    lda #$51
    sta $8f

    ldy #0
    start_level_add_treasure_loop:

        cpy $80                         ; check for the key room
        bne start_level_add_treasure_item

        lda #5                          ; the value to store is type + 1
        jmp start_level_add_treasure_store

        start_level_add_treasure_item:
        clc
        jsr unlimited_values
        and #$0f
        cmp #0
        beq start_level_add_treasure_none

        clc
        sta $8c
        tya
        adc $8c
        and #31
        clc
        tax
        lda treasure_table,x

        cmp #4
        bmi start_level_add_treasure_weapon

        clc
        adc #1
        jmp start_level_add_treasure_store

        start_level_add_treasure_weapon:

        ; Only add weapons with types that equal the level number or exceed it
        ; by one.
        cmp $3df1                     
        bcs start_level_add_treasure_none

        clc
        adc #1                              ; store values 0-8 as values 1-9
        jmp start_level_add_treasure_store

        start_level_add_treasure_none:
        clc
        lda #0                  ; do not put treasure in this room

        start_level_add_treasure_store:
        clc
        sta ($8e),y             ; add the item to the table

        iny
        cpy #121
        bmi start_level_add_treasure_loop

    clc
    rts

main:
    jsr init

    main_loop:

        jsr show_title

        main_wait_loop:
            lda #129
            ldx #157
            ldy #255
            jsr $fff4
            cpy #255
            bne main_wait_loop

        jsr start_new_game

        level_loop:

            jsr start_level

            game_loop:

                jsr remove_characters

                jsr reset_unplot_buffer
                jsr reset_plot_buffer

                lda $3df2       ; current room (y)
                sta $78
                lda $3df3       ; current room (x)
                sta $79
                jsr plot_room
                jsr add_treasure

                lda #$00        ; plot the player
                sta $74
                lda #$3d
                sta $75
                jsr plot_character

                jsr plot_buffer

                lda #0         ; reset projectile counter
                sta $3dfd

                lda #0         ; reset motion counter
                sta $3dfe

                lda #63         ; reset generation counter
                sta $3dff

                room_loop:
                    jsr reset_unplot_buffer
                    jsr reset_plot_buffer

                    jsr move_characters

                    jsr move_projectile

                    lda $3df0   ; is player out of strength?
                    and #$40
                    beq room_loop_player_move
                    clc

                    dec $3df5           ; leave the loop when the delay
                    beq after_room_loop ; counter is about to reset

                    lda $3d01           ; leave the loop when the player
                    cmp #11             ; animation has finished
                    beq room_loop_after_player_move
                    clc

                    lda $3dfe
                    and #7
                    bne room_loop_after_player_move

                    lda #$00
                    sta $74
                    lda #$3d
                    sta $75

                    jsr unplot_character

                    inc $3d01
                    jsr plot_character
                    jmp room_loop_after_player_move

                    room_loop_player_move:

                    jsr check_fire_key
                    jsr move_player
                    bcs after_room_loop     ; check if we are leaving the level

                    room_loop_after_player_move:
                    clc

                    lda #19
                    jsr $fff4
                    jsr plot_buffer

                    ldx #143
                    jsr check_key
                    cpy #255
                    beq exit
                    clc

                    lda $3dfd
                    cmp #0
                    beq room_loop_no_update_projectile_counter

                    dec $3dfd

                    room_loop_no_update_projectile_counter:

                    dec $3dff   ; update generation counter

                    inc $3dfe   ; update motion counter
                    clc
                    jmp room_loop

                after_room_loop:
                clc

                lda $3df0
                and #$80
                bne exit_level

                lda $3df0
                and #$40
                bne game_over

                jmp game_loop

            exit_level:
            inc $3dfa
            jmp level_loop

            game_over:
            jsr show_game_over

        jmp main_loop

    exit:
    clc
    rts
