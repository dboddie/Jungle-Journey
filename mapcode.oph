; Copyright (C) 2011 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $1e00
jmp main

seeds:         .byte 100, 239, 183, 144   ; $ef, $b7, $90, $d6, $89
start_rooms_x: .byte 5,   3,   5,   10
start_rooms_y: .byte 5,   8,   1,   8
exit_rooms_x:  .byte 7,   9,   3,   0
exit_rooms_y:  .byte 0,   0,   9,   10

; These values need to be kept in sync - the room numbers must match their
; positions in the room array.
key_rooms_x:   .byte 1,   5,  10,   1
key_rooms_y:   .byte 0,   2,   6,   4
key_rooms:     .byte 1,  27,  76,  45  ; ky*11 + kx

treasure_table:  .byte 6, 5, 7, 1, 1, 5, 2, 7, 6, 2, 1, 7, 1, 7, 8, 7
treasure_table_: .byte 0, 7, 6, 7, 7, 7, 5, 0, 6, 3, 7, 7, 5, 7, 5, 0

unlimited_values:   ; $7c,$7d=first,second
                    ; Add $7c and $7d, store the result in $7d and the original
                    ; $7d value in $7c, returning the sum in the accumulator.
    lda $7c
    sta $7b
    lda $7d
    sta $7c
    adc $7b
    sta $7d
    clc
    rts

mod9:               ; A = value
    divide_loop:
        cmp #9
        bcc after_divide_loop   ; bmi should work here, I think, but it doesn't
        sec
        sbc #9
        jmp divide_loop

after_divide_loop:
    clc
    rts             ; A % 9

tile_values_map: .byte 0,1,0,0,0,0,2,3

next_value:         ; no argument
    jsr unlimited_values
    lda $7d
    jsr mod9
    and #7          ; (next value % 9) & 7
    tax
    lda tile_values_map,x
    sta $7b
    rts

; Room filling routines, writing to 0x579c to 0x57ff.

draw_top_line:      ; $76=tile number for exit/wall
    ldx #9
    lda #2

    draw_top_line_loop0:
        sta $579c,x
        dex
        bpl draw_top_line_loop0

    ldx #3                      ; draw the exit or wall
    lda $76
    draw_top_line_loop1:
        sta $579f,x
        dex
        bpl draw_top_line_loop1
    clc
    rts

draw_left_line:     ; $77=tile number for exit/wall
    ldx #90
    draw_left_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop0

    ldx #30
    draw_left_line_loop1:
        lda $77
        sta $57ba,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop1
    clc
    rts

draw_bottom_line:       ; $76=tile number for exit/wall
    ldx #9
    lda #2
    draw_bottom_line_loop0:
        sta $57f6,x
        dex
        bpl draw_bottom_line_loop0

    ldx #3
    lda $76
    draw_bottom_line_loop1:
        sta $57f9,x
        dex
        bpl draw_bottom_line_loop1
    clc
    rts

draw_right_line:        ; $77=tile number for exit/wall
    ldx #99
    draw_right_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop0

    ldx #30
    draw_right_line_loop1:
        lda $77
        sta $57c3,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop1
    clc
    rts

make_empty_room:

    ldx #99
    make_empty_room_loop:
        lda #0
        sta $579c,x
        dex
        bpl make_empty_room_loop
    
    rts

make_room:          ; $78,$79=i,j

    ; Fills the room array at 579c with values.
    ; Tiles 0,1,2,3 are map tiles that will be shown by the plot_tile routine.
    ; Other tiles are plotted separately:
    ;   4 = exit
    ;   5 = final exit
    ;   6 = weapon (bits 3,4 are type)
    ;   7 = treasure (bits 3,4 are type)

    ; Fill the room with empty space.

    jsr make_empty_room

    ; Determine if there is a top exit.

    lda #0
    sta $76

    lda $78         ; i == 0
    cmp #0
    bne not_top_screen
    lda #2
    sta $76
    jmp do_top_exit

    not_top_screen:
    clc

    lda $78
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_top_exit
    clc

    lda $78
    eor $79         ; i ^ j
    adc $78         ; + i
    clc
    cmp $79         ; (i ^ j) + i == j
    bne do_top_exit
    lda #2
    sta $76         ; top exit

    do_top_exit:
    jsr draw_top_line

    ; Determine if there is a left exit.
    lda #0
    sta $77

    lda $79
    cmp #0
    bne not_left_screen
    lda #2
    sta $77
    jmp do_left_exit

    not_left_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    and #3          ; j & 3
    cmp $70
    beq do_left_exit
    clc

    lda $78
    ora $79         ; i | j
    eor $79         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_left_exit
    lda #2
    sta $77         ; left exit

    do_left_exit:
    jsr draw_left_line

    ; Determine if there is a right exit.
    lda #0
    sta $77

    lda $79
    cmp #10
    bne not_right_screen
    lda #2
    sta $77
    jmp do_right_exit

    not_right_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    adc #1
    and #3          ; j & 3
    cmp $70
    beq do_right_exit
    clc

    lda $79
    adc #1
    sta $70

    lda $78
    ora $70         ; i | j
    eor $70         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_right_exit
    lda #2
    sta $77         ; right exit

    do_right_exit:
    jsr draw_right_line

    ; Determine if there is a bottom exit.
    lda #0
    sta $76

    lda $78
    cmp #10
    bne not_bottom_screen
    lda #2
    sta $76
    jmp do_bottom_exit

    not_bottom_screen:
    clc

    lda $78
    adc #1
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_bottom_exit
    clc

    lda $78
    adc #1
    sta $70

    eor $79         ; i ^ j
    adc $70         ; + i
    cmp $79         ; (i ^ j) + i == j
    bne do_bottom_exit
    lda #2
    sta $76         ; bottom exit

    do_bottom_exit:
    jsr draw_bottom_line

    ; Add the final exit.

    lda $578a
    cmp #3
    bmi make_room_no_final_exit

    lda $78
    cmp #0
    bne make_room_no_final_exit

    lda $79
    cmp #2
    bne make_room_no_final_exit

    lda #6
    sta $57a0
    lda #7
    sta $57a1

    make_room_no_final_exit:

    ; Make sure that the starting, exit, key rooms are empty.

    ldx $578a               ; level number
    lda start_rooms_y,x
    cmp $78
    bne make_room_not_starting_room
    lda start_rooms_x,x
    cmp $79
    bne make_room_not_starting_room

    lda #3
    sta $70
    jmp add_room_decoration ; optimise away the rts

    make_room_not_starting_room:

    lda exit_rooms_y,x
    cmp $78
    bne make_room_not_exit_room
    lda exit_rooms_x,x
    cmp $79
    bne make_room_not_exit_room

    ; Add an exit to the room.
    lda $78
    eor $79
    and #15
    tax
    lda exit_room_offsets,x
    tax
    lda $5780
    and #1
    beq exit_not_open

    lda #5
    sta $579c,x
    jmp exit_decoration

    exit_not_open:
    clc
    lda #4
    sta $579c,x

    exit_decoration:
    lda #3
    sta $70
    jmp add_room_decoration ; optimise away the rts

    make_room_not_exit_room:

    lda key_rooms_y,x
    cmp $78
    bne make_room_not_key_room
    lda key_rooms_x,x
    cmp $79
    bne make_room_not_key_room

    lda #1
    sta $70
    jmp add_room_decoration ; optimise away the rts

    make_room_not_key_room:
    clc

    ; Fill in the room details.

    lda $79
    sta $7c
    sec
    ldx $578a
    lda seeds,x
    sbc $78
    sec
    sta $7d
    clc

    ; Discard the first ten values.

    ldy #10
    make_room_loop0:
        jsr unlimited_values
        dey
        bne make_room_loop0
    
    ; Fill the room array with values.

    lda #$a7
    sta $70
    lda #$57
    sta $71

    ldy #0
    make_room_loop1:

        jsr next_value
        sta ($70),y
        iny
        cpy #8
        bne make_room_loop1     ; continue the same row

        lda $70
        cmp #$ed
        beq make_room_loop1_exit    ; exit after the last row

        adc #10
        sta $70
        ldy #0                  ; reset the row counter
        jmp make_room_loop1
    
    make_room_loop1_exit:
    rts

decoration_offsets: .byte 11,18,81,88

add_room_decoration:

    lda #$9c
    sta $8e
    lda #$57
    sta $8f
    
    ldx #3
    add_room_decoration_loop:

        lda decoration_offsets,x
        tay
        lda $70
        sta ($8e),y
        dex
        bpl add_room_decoration_loop
    
    clc
    rts

exit_room_offsets:  .byte 35,66,63,56,34,44,64,33,36,55,65,53,45,46,54,43
treasure_x:         .byte 3, 2, 4, 8, 2, 5, 4, 1, 3, 8, 6, 5, 7, 1, 7, 6
treasure_y:         .byte 1, 3, 7, 7, 2, 3, 6, 1, 4, 6, 8, 5, 5, 4, 8, 2

eleven_times_table: .byte 0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110

add_treasure:               ; $78,$79 = i,j

    lda $78
    tax
    lda eleven_times_table,x
    adc $79
    tax

    lda $5200,x
    ora #$80
    sta $5200,x         ; set the top bit (room visited)
    and #$7f            ; mask off the top bit to obtain the item number + 1
    cmp #0
    beq add_treasure_exit

    sec
    sbc #1
    sta $528d           ; store weapon/treasure type
    clc

    lda $78
    eor $79
    adc $528d
    and #15
    sta $70

    lda #15
    sta $8c
    ldy #0
    add_treasure_loop:

        clc

        ldx $70
        lda treasure_y,x    ; y
        sta $8d
        tax
        lda room_row_offsets_low,x
        sta $80

        ldx $70
        lda treasure_x,x    ; x
        sta $8e
        adc $80
        sta $80

        lda #$57
        adc #0
        sta $81
        clc

        lda ($80),y         ; tile
        cmp #0
        bne add_treasure_loop_next

        lda #4              ; type (weapon/treasure)
        sta $528c
        lda $8d             ; y
        sta $528e
        lda #1              ; dy
        sta $528f
        lda $8e             ; x
        sta $5290
        lda #0              ; dx
        sta $5291

        lda #$8c
        sta $74
        lda #$52
        sta $75
        jmp plot_character  ; optimise away the rts

        add_treasure_loop_next:
        dec $8c
        bmi add_treasure_exit

        dec $70
        bpl add_treasure_loop

        lda #15
        sta $70
        jmp add_treasure_loop

    add_treasure_exit:
    clc
    rts

create_enemy_positions:

    lda #31     ; counter
    sta $7e

    lda #1      ; x
    sta $70

    lda #1      ; y
    sta $71

    lda #$a7
    sta $72
    lda #$57
    sta $73

    ldx #15     ; offset into position areas
    ldy #0

    create_enemy_positions_loop:

        jsr unlimited_values
        and #7
        sta $80     ; store temporarily

        lda $72
        adc $80
        sta $72     ; update the offset into the room data
        clc

        lda $70
        adc $80     ; update x
        cmp #10
        bpl create_enemy_positions_next_row

        sta $70     ; store x
        jmp create_enemy_positions_check_tile

        create_enemy_positions_next_row:

        sec
        sbc #10
        sta $70     ; store the x position on the next row
        clc

        lda $71
        adc #1      ; update the y position
        cmp #10
        bpl create_enemy_positions_to_top

        sta $71     ; store the y position for the next row
        jmp create_enemy_positions_check_tile

        create_enemy_positions_to_top:

        lda #1      ; reset the x, y and offset values
        sta $70
        sta $71
        lda #$a7
        sta $72

        create_enemy_positions_check_tile:

        lda ($72),y
        cmp #0
        bne create_enemy_positions_next

        lda $70
        sta $0ee0,x                     ; store the x value

        lda $71
        sta $0ef0,x                     ; store the y value

        dex
        bmi create_enemy_positions_exit

        create_enemy_positions_next:
        clc
        dec $7e
        bpl create_enemy_positions_loop

    ; The position areas were not filled. Write invalid values into the
    ; first area for the emerge routine to find.

    lda #0
    create_enemy_positions_fill_loop:

        sta $0ee0,x
        dex
        bpl create_enemy_positions_fill_loop

    create_enemy_positions_exit:
    clc
    rts

plot:               ; $70,$71=source address
                    ; $72,$73=destination address
    ldy #$1f
    plotloop0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    plotloop1:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$20
        bpl plotloop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    plotloop2:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$40
        bpl plotloop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts



plot_blank_xy:      ; X=y, Y=x

    lda screen_rows_low,x
    sta $72
    lda screen_rows_high,x
    sta $73

    tya
    tax
    lda screen_columns_low,x
    adc $72
    sta $72
    lda screen_columns_high,x
    adc $73
    sta $73
    clc
    ; run on into plot_blank

plot_blank:         ; $72,$73=destination address

    ldy #$1f
    lda #0
    plot_blank_loop0:
        sta ($72),y
        dey
        bpl plot_blank_loop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    lda #0
    plot_blank_loop1:
        sta ($72),y
        dey
        cpy #$20
        bpl plot_blank_loop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    lda #0
    plot_blank_loop2:
        sta ($72),y
        dey
        cpy #$40
        bpl plot_blank_loop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts

tile_addresses_low:  .byte $00, $60, $c0, $00, $60, $c0, $20
tile_addresses_high: .byte $54, $54, $54, $50, $50, $50, $51

plot_tile:          ; $7b=tile number
                    ;   1 = flowers/decoration
                    ;   2 = trees/wall
                    ;   3 = trees
                    ;   4 = exit
                    ;   5 = open exit
                    ;   6 = final exit (left)
                    ;   7 = final exit (right)
                    ; $72,$73=screen position 

    lda $7b
    cmp #0
    bne plot_tile_sprite
    clc
    jmp plot_blank      ; optimise away the rts

    plot_tile_sprite:
    clc
    tax
    dex
    lda tile_addresses_low,x
    sta $70
    lda tile_addresses_high,x
    sta $71

    lda $7b
    cmp #4
    bpl plot_not_blank_after_add_loop   ; don't adjust the tile for later levels
    
    clc
    lda $578a
    and #3              ; change the tile set for later levels
    tax

    plot_not_blank_add_loop:

        cpx #2
        bne plot_not_blank_not_2
        dex
        jmp plot_not_blank_not_0

        plot_not_blank_not_2:
        beq plot_not_blank_add_loop
        cpx #0

        plot_not_blank_not_0:
        beq plot_not_blank_after_add_loop
        clc
        lda $70
        adc #$20
        sta $70
        lda $71
        adc #$01
        sta $71
        dex
        jmp plot_not_blank_add_loop

    plot_not_blank_after_add_loop:
    clc
    jsr plot
    rts

plot_room:          ; $78,$79 = i,j (from $5782,$5783)
    jsr blank_screen

    lda $5782
    sta $78
    lda $5783
    sta $79

    jsr make_room
    ; Run on into the next piece of code.

plot_room_tiles:

    lda #$80
    sta $72
    lda #$5a
    sta $73         ; $72,$73 = screen position

    lda #0
    sta $7a
    row_loop:

        lda #9
        sta $76

        column_loop:
            lda $7a
            tax
            lda $579c,x
            sta $7b
            jsr plot_tile

            inc $7a
            lda $76
            sec
            sbc #1
            sta $76
            clc
            cmp #0
            bpl column_loop

        clc

        lda $72
        adc #$80
        sta $72
        lda $73
        adc #$02
        sta $73
        clc
        cmp #$80
        beq end_rows

        jmp row_loop
    
end_rows:
    rts

set_room_palette:   ; $78=i; $79=j

    lda #1
    sta $70
    lda $78
    eor $79
    and #3
    tax
    lda room_palettes,x
    sta $71
    jsr set_palette

    jsr set_core_palette
    rts

room_palettes: .byte 1, 6, 5, 7

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c

plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2

    plot8x24_y0_loop:

        ldy #15

        plotloop8x24_y0_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y0_0

        dex
        bmi plot8x24_y0_exit
        
        lda $72
        adc #$40
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        lda $70
        adc #16
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        jmp plot8x24_y0_loop

    plot8x24_y0_exit:
    clc
    jmp plot_buffer_loop_next


plot8x8_y1:             ; $70,$71=source address
                        ; $72,$73=destination address
    lda #2
    sta $7e
    lda #10
    sta $7f

    lda #0              ; plotting 1 8x8 piece
    sta $8a

    jmp plot8x24_y123   ; optimise away the rts

plot8x24_y1:            ; $70,$71=source address
                        ; $72,$73=destination address
    lda #2
    sta $7e
    lda #10
    sta $7f

    lda #2              ; plotting 3 8x8 pieces
    sta $8a

    jmp plot8x24_y123   ; optimise away the rts

plot8x8_y2:             ; $70,$71=source address
                        ; $72,$73=destination address
    lda #4
    sta $7e
    lda #12
    sta $7f

    lda #0              ; plotting 1 8x8 piece
    sta $8a

    jmp plot8x24_y123   ; optimise away the rts

plot8x24_y2:            ; $70,$71=source address
                        ; $72,$73=destination address
    lda #4
    sta $7e
    lda #12
    sta $7f

    lda #2              ; plotting 3 8x8 pieces
    sta $8a

    jmp plot8x24_y123   ; optimise away the rts

plot8x8_y3:             ; $70,$71=source address
                        ; $72,$73=destination address
    lda #6
    sta $7e
    lda #14
    sta $7f

    lda #0              ; plotting 1 8x8 piece
    sta $8a

    jmp plot8x24_y123   ; optimise away the rts

plot8x24_y3:            ; $70,$71=source address
                        ; $72,$73=destination address
    lda #6
    sta $7e
    lda #14
    sta $7f

    lda #2              ; plotting 3 8x8 pieces
    sta $8a

    ; Run on into the next routine.

plot8x24_y123:          ; $70,$71=source address
                        ; $72,$73=destination address
                        ; $7e=offset into source data for first column
                        ; $7f=offset into source data for second column

    plot8x24_y123_loop:

        ldx #0
        plot8x24_y123_upper_loop_outer:

            ldy $7e,x
            lda plot_upper_offsets,x
            sta $89

            plot8x24_y123_upper_loop_inner:     ; plot the first column until
                dey                             ; we reach the start
                cpy $89
                bmi plot8x24_y123_upper_loop_inner_endloop
                lda ($70),y
                eor ($72),y
                sta ($72),y
                jmp plot8x24_y123_upper_loop_inner

            plot8x24_y123_upper_loop_inner_endloop:
            clc

            inx
            cpx #2
            bne plot8x24_y123_upper_loop_outer

        clc
        lda $72       ; move the destination pointer to refer to the next line
        adc #$38
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldx #0
        plot8x24_y123_lower_loop_outer:
        
            lda plot_lower_offsets,x
            tay
            lda $7e,x
            sta $89

            plot8x24_y123_lower_loop_inner: ; plot until we reach the initial
                lda ($70),y                 ; offset for the column
                eor ($72),y
                sta ($72),y
                dey
                cpy $89
                bpl plot8x24_y123_lower_loop_inner

            inx
            cpx #2
            bne plot8x24_y123_lower_loop_outer
        
        dec $8a
        bmi plot8x24_y123_exit

        clc
        lda $70         ; update the source pointer to refer to the next piece
        adc #16         ; of sprite data
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; update the destination pointer to point to the next
        adc #8          ; space
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        jmp plot8x24_y123_loop

    plot8x24_y123_exit:
    clc
    jmp plot_buffer_loop_next

plot16x16_y0:           ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #31

    plotloop16x16_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop16x16_y0_0
    clc

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 32
    clc

    ldy #63

    plotloop16x16_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop16x16_y0_1
    clc

    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c 30 34 38 3c

plot16x16_y1:           ; $70,$71=source address
                        ; $72,$73=destination address

    lda #2
    sta $7e
    lda #10
    sta $7f
    lda #18
    sta $80
    lda #26
    sta $81
    jmp plot16x16_y123  ; optimise away the rts

plot16x16_y2:           ; $70,$71=source address
                        ; $72,$73=destination address

    lda #4
    sta $7e
    lda #12
    sta $7f
    lda #20
    sta $80
    lda #28
    sta $81
    jmp plot16x16_y123  ; optimise away the rts

plot16x16_y3:           ; $70,$71=source address
                        ; $72,$73=destination address

    lda #6
    sta $7e
    lda #14
    sta $7f
    lda #22
    sta $80
    lda #30
    sta $81
    ; Run on into the next routine.

plot16x16_y123:         ; $70,$71=source address
                        ; $72,$73=destination address
                        ; $7e=offset into source data for first column
                        ; $7f=offset into source data for second column
                        ; $80=offset into source data for third column
                        ; $81=offset into source data for fourth column

    lda #1
    sta $8a

    plot16x16_y123_loop:

        ldx #0
        plot16x16_y123_upper_loop_outer:

            ldy $7e,x
            lda plot_upper_offsets,x
            sta $89

            plot16x16_y123_upper_loop_inner:

                dey
                cpy $89
                bmi plot16x16_y123_upper_loop_inner_endloop
                lda ($70),y
                eor ($72),y
                sta ($72),y
                jmp plot16x16_y123_upper_loop_inner

            plot16x16_y123_upper_loop_inner_endloop:
            clc

            inx
            cpx #4
            bne plot16x16_y123_upper_loop_outer

        clc
        lda $72       ; move the destination pointer to refer to the next line
        adc #$38
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldx #0
        plot16x16_y123_lower_loop_outer:

            lda plot_lower_offsets,x
            tay
            lda $7e,x
            sta $89

            plot16x16_y123_lower_loop_inner:    ; plot until we reach the initial offset
                lda ($70),y                     ; for the column
                eor ($72),y
                sta ($72),y
                dey
                cpy $89
                bpl plot16x16_y123_lower_loop_inner

            inx
            cpx #4
            bne plot16x16_y123_lower_loop_outer

        dec $8a
        bmi plot16x16_y123_exit

        clc
        lda $70         ; update the source pointer to refer to the next piece
        adc #32         ; of sprite data
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; update the destination pointer to point to the next
        adc #8          ; space
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        jmp plot16x16_y123_loop

    plot16x16_y123_exit:
    clc
    jmp plot_buffer_loop_next

plot_upper_offsets: .byte 0, 8, 16, 24
plot_lower_offsets: .byte 7, 15, 23, 31

plot8x8_y0:             ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop8x8_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop8x8_y0_0
    clc

    jmp plot_buffer_loop_next


check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

player_direction_chars_low: .byte $00,$30,$60,$90,$c0,$f0,$20,$50, $80,$b0,$e0,$10
player_direction_chars_high: .byte $3f,$3f,$3f,$3f,$3f,$3f,$40,$40, $40,$40,$40,$41

screen_rows_low: .byte $80,$40,$00,$c0,$80,$40,$00,$c0,$80,$40
screen_rows_high: .byte $5a,$5e,$62,$65,$69,$6d,$71,$74,$78,$7c
screen_subrows_low: .byte $00,$06,$44,$82
screen_subrows_high: .byte $00,$00,$01,$02

screen_columns_low: .byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00,$20
screen_columns_high: .byte $00,$00,$00,$00,$00,$00,$00,$00,$01,$01
screen_subcolumns_low: .byte $00,$08,$10,$18

enemy_direction_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80
enemy_direction_chars_high: .byte $41,$42,$42,$42,$42,$43,$43,$43

emerge_explode_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80
emerge_explode_chars_high: .byte $4b,$4c,$4c,$4c,$4c,$4d,$4d,$4d

item_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80,$c0
item_chars_high: .byte $4d,$4e,$4e,$4e,$4e,$4f,$4f,$4f,$4f

projectile_chars_low: .byte $40,$50,$60,$70,$80,$90,$a0,$b0

unplot_character:       ; $74,$75=character address

    lda $82             ; store the unplot buffer address in $78,$79
    sta $78
    lda $83
    sta $79
    jsr plot_character_sprite
    lda $78
    sta $82             ; update the latest space in the unplot buffer
    rts

plot_character:         ; $74,$75=character address

    lda $84             ; store the plot buffer address in $78,$79
    sta $78
    lda $85
    sta $79
    jsr plot_character_sprite
    lda $78
    sta $84             ; update the latest space in the plot buffer
    rts

plot_character_sprite:  ; $74,$75=character address
                        ; $78,$79=unplot/plot buffer address

    ldy #0
    lda ($74),y
    cmp #0
    bne plot_characters_read_character
    jmp plot_characters_next

    plot_characters_read_character:
    clc

    sta $77         ; temporarily store the object type

    ; Use lookup tables to load the offsets into the sprite.

    ; Direction
    iny
    lda ($74),y
    sta $80         ; temporarily store the direction

    ; y
    iny
    lda ($74),y
    tax
    lda screen_rows_low,x
    sta $72
    lda screen_rows_high,x
    sta $73
    clc

    ; dy
    iny
    lda ($74),y
    sta $76
    tax
    lda screen_subrows_low,x
    adc $72
    sta $72
    lda screen_subrows_high,x
    adc $73
    sta $73
    clc

    ; x
    iny
    lda ($74),y
    tax
    lda screen_columns_low,x
    adc $72
    sta $72
    lda screen_columns_high,x
    adc $73
    sta $73
    clc

    ; dx
    iny
    lda ($74),y
    tax
    lda screen_subcolumns_low,x
    adc $72
    sta $72
    clc

    lda $77
    cmp #1
    bne plot_characters_loop_not_player

    ; Plot 8x24 sprites (player)

    ldx $80
    lda player_direction_chars_low,x
    sta $70
    lda player_direction_chars_high,x
    sta $71

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    ldx $76
    lda plot_routine_indices_8x24,x

    sta ($78),y
    jmp plot_characters_stored


    plot_characters_loop_not_player:
    cmp #2
    bne plot_characters_loop_not_projectile

    ; Plot 8x8 sprites (projectiles)

    lda $80
    and #7
    tax
    lda projectile_chars_low,x
    sta $70
    lda #$41
    sta $71

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    ldx $76
    lda plot_routine_indices_8x8,x

    sta ($78),y
    jmp plot_characters_stored


    plot_characters_loop_not_projectile:
    cmp #3
    bne plot_characters_loop_not_explosion

    ; Plot 16x16 sprites (emerging, explosions)

    ; Select the sprites to use.

    lda $80
    and #7          ; only keep the bits required to find the correct sprite
    clc
    tax
    lda emerge_explode_chars_low,x
    sta $70
    lda emerge_explode_chars_high,x
    sta $71

    jmp plot_characters_16x16

    plot_characters_loop_not_explosion:
    cmp #4
    bne plot_characters_loop_not_item

    ; Plot 16x16 sprites (items)

    ; Select the sprites to use.

    lda $80
    and #$0f        ; only keep the bits required to find the correct sprite
    clc
    tax
    lda item_chars_low,x
    sta $70
    lda item_chars_high,x
    sta $71

    jmp plot_characters_16x16

    plot_characters_loop_not_item:
    cmp #8
    bmi plot_characters_loop_not_enemy

    ; Plot 16x16 sprites (enemies)

    ; Select the set of sprites to use.

    and #$70
    lsr
    lsr
    lsr     ; bits 4,5,6 >> 3 -> bits 1,2,3
    clc
    sta $71 ; 0x00, 0x02, 0x04, 0x06, 0x08

    lda $80
    and #7          ; keep the animation bits
    tax
    lda enemy_direction_chars_low,x
    sta $70
    lda enemy_direction_chars_high,x
    adc $71
    sta $71

    plot_characters_16x16:

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    ldx $76
    lda plot_routine_indices_16x16,x

    sta ($78),y

    plot_characters_stored:

    iny
    lda $70
    sta ($78),y
    iny
    lda $71
    sta ($78),y
    iny
    lda $72
    sta ($78),y
    iny
    lda $73
    sta ($78),y

    clc
    lda $78
    adc #12
    sta $78

    plot_characters_loop_not_enemy:

    plot_characters_next:

    lda #255    ; terminate this stream of entries in the plot buffer
    ldy #0
    sta ($78),y
    clc
    rts

plot_routine_indices_8x24:  .byte 1, 2, 3, 4
plot_routine_indices_8x8:   .byte 5, 6, 7, 8
plot_routine_indices_16x16: .byte 9, 10, 11, 12

reset_plot_buffer:
    lda #$06    ; reset the index into the plot buffer
    sta $84
    lda #$53
    sta $85

    lda #255    ; terminate the plot list
    ldy #0
    sta ($84),y
    rts

reset_unplot_buffer:
    lda #$00    ; reset the index into the plot buffer
    sta $82
    lda #$53
    sta $83

    lda #255    ; terminate the unplot list
    ldy #0
    sta ($82),y
    rts

plot_buffer_types_low:  .byte <plot_buffer_loop_next
plot_buffer_types_low1: .byte <plot8x24_y0, <plot8x24_y1, <plot8x24_y2, <plot8x24_y3
plot_buffer_types_low2: .byte <plot8x8_y0, <plot8x8_y1, <plot8x8_y2, <plot8x8_y3
plot_buffer_types_low3: .byte <plot16x16_y0, <plot16x16_y1, <plot16x16_y2, <plot16x16_y3

plot_buffer_types_high:  .byte >plot_buffer_loop_next
plot_buffer_types_high1: .byte >plot8x24_y0, >plot8x24_y1, >plot8x24_y2, >plot8x24_y3
plot_buffer_types_high2: .byte >plot8x8_y0, >plot8x8_y1, >plot8x8_y2, >plot8x8_y3
plot_buffer_types_high3: .byte >plot16x16_y0, >plot16x16_y1, >plot16x16_y2, >plot16x16_y3

plot_buffer:

    lda #$00
    sta $84
    lda #$53
    sta $85

    lda #6
    sta $88

    plot_buffer_loop:

        ldy #0
        lda ($84),y
        cmp #255
        beq plot_buffer_loop_skip

        clc
        tax
        lda plot_buffer_types_low,x
        sta $86
        lda plot_buffer_types_high,x
        sta $87

        iny
        lda ($84),y
        sta $70

        iny
        lda ($84),y
        sta $71

        iny
        lda ($84),y
        sta $72

        iny
        lda ($84),y
        sta $73

        jmp ($86)       ; returns to plot_buffer_loop_next

        plot_buffer_loop_skip:

        lda $88
        cmp #12
        beq plot_buffer_exit    ; both unplot and plot lists have terminated

        lda #12
        sta $88
        lda $84
        adc #6
        sta $84
        jmp plot_buffer_loop

        plot_buffer_loop_next:
        clc

        lda $84
        adc $88
        sta $84
        jmp plot_buffer_loop

    plot_buffer_exit:
    clc
    rts

room_row_offsets_low: .byte $9c,$a6,$b0,$ba,$c4,$ce,$d8,$e2,$ec,$f6

animate_player_left:

    ; Set the direction and toggle the animation bit.

    lda $5281
    and #1
    eor #1      ; toggle animation flag
    sta $5281   ; left (directional bits are 0)

    jsr plot_character
    rts

animate_player_right:

    ; Set the direction and toggle the animation bit.

    lda $5281
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #2      ; right
    sta $5281

    jsr plot_character
    rts

animate_player_up:

    ; Set the direction and toggle the animation bit.

    lda $5281
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #4      ; up
    sta $5281

    jsr plot_character
    rts

animate_player_down:

    ; Set the direction and toggle the animation bit.

    lda $5281
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #6      ; down
    sta $5281

    jsr plot_character
    rts

move_player:

    lda $578e
    and #1
    beq move_player_allowed

    clc
    rts

    move_player_allowed:

    lda #$80    ; set up the address of the player character
    sta $74
    lda #$52
    sta $75

    ; Handle joystick

    lda $577e
    cmp #0
    beq move_player_handle_left_key

    lda #128
    ldx #1
    jsr $fff4
    cpy #0
    beq move_player_handle_joystick_up_down
    cpy #128
    bpl move_player_left
    jmp move_player_right

    move_player_handle_joystick_up_down:

    lda #128
    ldx #2
    jsr $fff4
    cpy #0
    beq move_player_handle_left_key
    cpy #128
    bpl move_player_not_up
    jmp move_player_up

    move_player_not_up:
    jmp move_player_down

    move_player_handle_left_key:

    ; Handle the left key.

    ldx #158            ; (Z)
    jsr check_key
    cpy #255
    bne move_player_not_left_key

    move_player_left:

    lda $5285           ; read dx
    cmp #0
    beq move_player_left_check_x

    jsr unplot_character        ; unplot the player character
    dec $5285
    clc
    jmp animate_player_left ; optimise away the rts
    
    move_player_left_check_x:   ; Check the x offset.

    lda $5284
    cmp #0
    beq move_player_leave_room_left

    clc
    tay
    dey                         ; x - 1
    lda $5282                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the left

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_left_exit1
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_left_exit1:
    cmp #0
    bne move_player_not_left_key

    lda $5283               ; dy
    cmp #0
    beq move_player_allow_left

    clc
    lda $70                 ; dy > 0 so we need to check another tile
    adc #10
    sta $70
    lda ($70),y             ; load the tile below and to the left

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_left_exit2
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_left_exit2:
    cmp #0
    bne move_player_not_left_key

    move_player_allow_left:
    tya
    sta $81                 ; temporary
    jsr unplot_character    ; unplot the player character
    lda $81
    sta $5284               ; store the new room x offset
    lda #3
    sta $5285               ; dx = 3
    clc
    jmp animate_player_left ; optimise away the rts

    move_player_leave_room_left:
    sec
    lda $5783
    sbc #1
    sta $5783
    clc

    ; Set the player's position on the right of the screen.
    
    ; No need to unplot.

    lda #9      ; x = 9
    sta $5284
    lda #2      ; dx = 2
    sta $5285

    jsr animate_player_left
    sec                     ; indicate to the calling routine that the player
    rts                     ; has left the room

    move_player_not_left_key:

    ; Handle the right key.

    ldx #189            ; (X)
    jsr check_key
    cpy #255
    beq move_player_right
    jmp move_player_not_right_key

    move_player_right:

    lda $5285                   ; read dx
    cmp #2
    beq move_player_right_check_x
    cmp #3
    beq move_player_right_tile

    jsr unplot_character        ; unplot the player character
    inc $5285
    clc
    jmp animate_player_right    ; optimise away the rts
    
    move_player_right_check_x:  ; Check the x offset.

    lda $5284
    cmp #9
    beq move_player_leave_room_right

    clc
    tay
    iny                         ; x + 1
    lda $5282                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_right_exit1
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_right_exit1:
    cmp #0
    bne move_player_not_right_key

    lda $5283                   ; dy
    cmp #0
    beq move_player_allow_right

    clc                         ; dy > 0 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_right_exit2
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_right_exit2:
    cmp #0
    bne move_player_not_right_key

    move_player_allow_right:

    jsr unplot_character        ; unplot the player character
    inc $5285                   ; update dx
    clc
    jmp animate_player_right    ; optimise away the rts

    move_player_right_tile:

    jsr unplot_character    ; unplot the player character
    inc $5284               ; store the new room x offset
    lda #0
    sta $5285               ; dx = 0
    clc
    jmp animate_player_right ; optimise away the rts

    move_player_leave_room_right:
    clc
    inc $5783
    clc

    ; Set the player's position on the left of the screen.

    ; No need to unplot.

    lda #0      ; x = 0
    sta $5284
    lda #0      ; dx = 0
    sta $5285

    jsr animate_player_right    
    sec                         ; indicate to the calling routine that the
    rts                         ; player has left the room

    move_player_not_right_key:

    ; Handle the up key.

    ldx #183            ; (:)
    jsr check_key
    cpy #255
    bne move_player_not_up_key

    move_player_up:

    lda $5283           ; read dy
    cmp #0
    beq move_player_up_check_y

    jsr unplot_character        ; unplot the player character
    dec $5283
    clc
    jmp animate_player_up       ; optimise away the rts
    
    move_player_up_check_y:     ; Check the y offset.

    lda $5282
    cmp #0
    beq move_player_leave_room_up

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    ldy $5284                   ; load the x offset
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_up_exit1
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_up_exit1:
    cmp #0
    bne move_player_not_up_key

    lda $5285                   ; dx
    cmp #3
    bmi move_player_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_up_exit2
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_up_exit2:
    cmp #0
    bne move_player_not_up_key

    move_player_allow_up:
    txa
    sta $81                 ; temporary
    jsr unplot_character    ; unplot the player character
    lda $81
    sta $5282               ; store the new room y offset
    lda #3
    sta $5283               ; dy = 3
    clc
    jmp animate_player_up   ; optimise away the rts

    move_player_leave_room_up:
    sec
    lda $5782
    sbc #1
    sta $5782
    clc

    ; Set the player's position on the bottom of the screen.

    ; No need to unplot.

    lda #9      ; y = 9
    sta $5282
    lda #0      ; dy = 0
    sta $5283

    jsr animate_player_up
    sec                     ; indicate to the calling routine that the player
    rts                     ; has left the room

    move_player_not_up_key:

    ; Handle the down key.

    ldx #151            ; (/)
    jsr check_key
    cpy #255
    beq move_player_down
    jmp move_player_not_down_key

    move_player_down:

    lda $5283                   ; read dy
    cmp #0
    beq move_player_down_check_y
    cmp #3
    beq move_player_down_tile

    jsr unplot_character        ; unplot the player character
    inc $5283                   ; 0 <= dy < 3
    clc
    jmp animate_player_down    ; optimise away the rts
    
    move_player_down_check_y:  ; Check the y offset.

    lda $5282
    cmp #9
    beq move_player_leave_room_down

    clc
    tax
    inx                         ; y + 1
    ldy $5284                   ; load the x offset
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_down_exit1
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_down_exit1:
    cmp #0
    bne move_player_not_down_key

    lda $5285                   ; dx
    cmp #3
    bmi move_player_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #5                      ; check for the open exit or final exit
    bmi move_player_not_down_exit2
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_down_exit2:
    cmp #0
    bne move_player_not_down_key

    move_player_allow_down:

    jsr unplot_character        ; unplot the player character
    inc $5283                   ; update dy
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_down_tile:

    jsr unplot_character        ; unplot the player character
    inc $5282                   ; store the new room y offset
    lda #0
    sta $5283                   ; dy = 0
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_leave_room_down:
    inc $5782
    clc

    ; Set the player's position on the top of the screen.

    ; No need to unplot.

    lda #0      ; y = 0
    sta $5282
    lda #0      ; dy = 0
    sta $5283

    jsr animate_player_down
    sec                         ; indicate to the calling routine that the
    rts                         ; player has left the room

    move_player_not_down_key:
    clc
    rts

try_to_exit_level:

    cmp #6
    bmi just_exit_level

    lda $5780                   ; set the complete game flag
    ora #$02
    jmp try_to_exit_level_exit

    just_exit_level:
    lda $5780                   ; set the exit level flag
    ora #$80

    try_to_exit_level_exit:
    sta $5780

    lda #$80
    sta $74
    lda #$52
    sta $75
    jsr unplot_character    ; remove the player sprite
    jmp destroy_enemies     ; optimise away the rts

check_fire_key:

    lda $578d
    bne check_fire_key_exit

    lda $577e
    beq check_fire_key_no_joystick

    lda #128
    ldx #0
    jsr $fff4
    cpx #0
    beq check_fire_key_fire

    check_fire_key_no_joystick:

    ldx #182            ; (Return)
    jsr check_key
    cpy #255
    bne check_fire_key_exit

    check_fire_key_fire:

    lda $5286
    cmp #0
    bne check_fire_key_exit

    lda #16
    sta $578d

    jmp create_projectile   ; optimise away the rts

    check_fire_key_exit:
    clc
    rts

create_projectile:

    lda #2
    sta $5286

    lda $5281
    and #$06        ; copy the direction information
    asl
    asl
    asl
    ora $5789       ; apply the projectile type
    sta $5287

    lda $5283       ; player dy
    adc $577f       ; add the weapon counter
    adc #1
    cmp #4          ; if dy > 3, create the projectile on the tile below
    bpl create_projectile_below

    clc
    sta $5289       ; dy + weapon counter + 1
    lda $5282       ; y
    sta $5288
    jmp create_projectile_continue

    create_projectile_below:
    sec
    sbc #4
    sta $5289       ; dy + weapon counter + 1 - 4
    clc
    lda $5282       ; y
    adc #1
    sta $5288

    create_projectile_continue:
    lda $5284       ; x
    sta $528a

    lda $5285       ; dx
    sta $528b

    lda $577f       ; toggle the weapon counter
    eor #1
    sta $577f

    ; Move the projectile away from the player.

    jsr move_projectile_after_unplot
    jsr move_projectile

    clc
    rts

emerge_type:                    ; returns A=type
    jsr unlimited_values
    lda $7d
    and #7
    cmp #4
    bmi emerge_type_ok

    sec
    sbc #4
    clc

    emerge_type_ok:
    cmp $5781               ; only allow the appropriate enemies for this level
    bmi emerge_type_exit

    sec
    sbc $5781
    clc

    emerge_type_exit:
    asl
    asl
    asl
    asl
    clc
    rts

emerge_character:           ; $74,$75=character address

    lda #63
    sta $578f

    jsr unlimited_values
    and #$0f
    tax
    lda $0ee0,x
    cmp #0                  ; check for an invalid value and exit if found
    beq emerge_character_exit

    sta $80                 ; temporary
    lda $0ef0,x
    tax

    ; Add an emerging enemy.

    ldy #0
    lda #3                  ; emerge/explosion
    sta ($74),y

    jsr emerge_type         ; obtain an enemy type
    iny
    sta ($74),y

    txa
    iny
    sta ($74),y             ; store the y position
    lda #1
    iny
    sta ($74),y             ; store the dy offset

    lda $80
    iny
    sta ($74),y             ; store the x position
    lda #0
    iny
    sta ($74),y             ; store the dx offset

    jsr plot_character

    ldx #5
    jsr play_sound

    emerge_character_exit:
    clc
    rts

emerge_explode:             ; $74,$75=character address

    jsr unplot_character

    ldy #1
    lda ($74),y     ; direction/animation
    tax
    adc #1          ; update the counter
    and #3          ; mask off everything else
    sta $80         ; store the masked counter value
    bne move_characters_explosion_not_finished

    txa
    and #4
    bne move_characters_remove_character

    ; For emerges, convert into an enemy.
    txa
    and #$70        ; only keep bits 4,5,6
    ora #8          ; make this an enemy

    ldy #0
    sta ($74),y     ; update the type (>= 8)
    iny
    lda $7d         ; prepare the direction and animation offset
    and #$0c
    sta ($74),y

    jsr plot_character
    jmp emerge_explode_exit

    move_characters_remove_character:

    ; For finished explosions, just write 0 into the character array.
    lda #0
    ldy #0
    sta ($74),y
    jmp emerge_explode_exit

    move_characters_explosion_not_finished:
    txa
    and #$fc
    ora $80

    ldy #1
    sta ($74),y

    jsr plot_character

    emerge_explode_exit:
    clc
    rts

animate_enemy_left:     ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    and #$fb    ; keep vertical direction bit and animation bits
    sta ($74),y ; left (horizontal directional bit is 0)

    rts

move_enemy_left:        ; $74,$75=character address

    ldy #5
    lda ($74),y         ; read dx
    cmp #0
    beq move_enemy_left_check_x

    sec
    sbc #1
    ldy #5
    sta ($74),y                 ; dx
    clc
    jmp animate_enemy_left      ; optimise away the rts

    move_enemy_left_check_x:

    ; Check the x offset.

    ldy #4
    lda ($74),y                 ; x
    cmp #0
    beq move_enemy_left_exit

    sec
    sbc #1                      ; x - 1
    sta $81                     ; temporary
    ldy #2
    lda ($74),y                 ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    ldy $81                     ; temporary (x - 1)
    lda ($70),y                 ; load the tile to the left

    cmp #0
    bne move_enemy_left_exit

    ldy #3
    lda ($74),y                 ; dy
    cmp #2
    bmi move_enemy_allow_left

    clc
    lda $70                 ; dy > 1 so we need to check another tile
    adc #10
    sta $70
    ldy $81                 ; temporary (x - 1)
    lda ($70),y             ; load the tile below and to the left

    cmp #0
    bne move_enemy_left_exit

    move_enemy_allow_left:
    lda $81
    ldy #4
    sta ($74),y             ; store the new room x offset
    lda #3
    ldy #5
    sta ($74),y             ; dx = 3
    clc
    jmp animate_enemy_left ; optimise away the rts

    move_enemy_left_exit:
    sec
    rts

animate_enemy_right:    ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    ora #$04    ; right (keep vertical direction bit and animation bits)
    sta ($74),y

    rts

move_enemy_right:       ; $74,$75=character_address

    ldy #5
    lda ($74),y                 ; read dx
    cmp #0
    beq move_enemy_right_check_x
    cmp #3
    beq move_enemy_right_tile

    clc
    adc #1
    ldy #5
    sta ($74),y
    jmp animate_enemy_right    ; optimise away the rts
    
    move_enemy_right_check_x:  ; Check the x offset.

    ldy #4
    lda ($74),y                 ; x
    cmp #9
    beq move_enemy_right_exit

    clc
    adc #1                      ; x + 1
    sta $81                     ; temporary (x + 1)
    ldy #2
    lda ($74),y                 ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    ldy $81                     ; temporary (x + 1)
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_enemy_right_exit

    ldy #3
    lda ($74),y                 ; dy
    cmp #2
    bmi move_enemy_allow_right

    clc                         ; dy > 1 so we need to check another tile
    lda $70
    adc #10
    sta $70
    ldy $81                     ; temporary (x + 1)
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_enemy_right_exit

    move_enemy_allow_right:
    clc

    ldy #5
    lda ($74),y                 ; dx
    adc #1
    sta ($74),y                 ; update dx
    clc
    jmp animate_enemy_right    ; optimise away the rts

    move_enemy_right_tile:
    clc

    ldy #4
    lda ($74),y             ; x
    adc #1
    sta ($74),y             ; store the new room x offset
    lda #0
    iny
    sta ($74),y             ; dx = 0
    clc
    jmp animate_enemy_right ; optimise away the rts

    move_enemy_right_exit:
    sec
    rts

animate_enemy_up:   ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    and #$f7    ; keep horizontal direction bit and animation bits
    sta ($74),y

    rts

move_enemy_up:      ; $74,$75=character address

    ldy #3
    lda ($74),y                 ; read dy
    cmp #0
    beq move_enemy_up_check_y

    sec
    sbc #1
    ldy #3
    sta ($74),y                 ; dy
    clc
    jmp animate_enemy_up        ; optimise away the rts
    
    move_enemy_up_check_y:

    ; Check the y offset.

    ldy #2
    lda ($74),y                 ; y
    cmp #0
    beq move_enemy_up_exit

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    ldy #4
    lda ($74),y                 ; load the x offset
    sta $81                     ; temporary (x)
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_enemy_up_exit

    ldy #5
    lda ($74),y                 ; dx
    cmp #0
    beq move_enemy_allow_up

    clc                     ; dx != 0 so we need to check another tile
    ldy $81
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_enemy_up_exit

    move_enemy_allow_up:
    txa
    ldy #2
    sta ($74),y             ; store the new room y offset
    lda #3
    iny
    sta ($74),y             ; dy = 3
    clc
    jmp animate_enemy_up   ; optimise away the rts

    move_enemy_up_exit:
    sec
    rts

animate_enemy_down: ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    ora #$08    ; down
    sta ($74),y

    rts

move_enemy_down:    ; $74,$75=character address    

    ldy #3
    lda ($74),y         ; dy
    cmp #1
    beq move_enemy_down_check_y
    cmp #3
    beq move_enemy_down_tile

    adc #1
    ldy #3
    sta ($74),y         ; dy
    clc
    jmp animate_enemy_down      ; optimise away the rts
    
    move_enemy_down_check_y:

    ; Check the y offset.

    ldy #2
    lda ($74),y
    cmp #9
    beq move_enemy_down_exit

    clc
    adc #1                      ; y + 1
    tax
    ldy #4
    lda ($74),y                 ; load the x offset
    sta $81                     ; temporary
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_enemy_down_exit

    ldy #5
    lda ($74),y                 ; dx
    cmp #0
    beq move_enemy_allow_down

    clc                         ; dx != 0 so we need to check another tile
    ldy $81                     ; x
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_enemy_down_exit

    move_enemy_allow_down:
    clc

    ldy #3
    lda ($74),y                 ; dy
    adc #1
    sta ($74),y                 ; update dy
    clc
    jmp animate_enemy_down      ; optimise away the rts

    move_enemy_down_tile:
    clc

    ldy #2
    lda ($74),y                 ; y
    adc #1
    sta ($74),y                 ; store the new room y offset
    lda #0
    iny
    sta ($74),y                 ; dy = 0
    clc
    jmp animate_enemy_down      ; optimise away the rts

    move_enemy_down_exit:
    sec
    rts

move_enemy_animate:     ; $74,$75=character address

    ldy #1
    lda ($74),y         ; direction/animation
    sta $81
    and #$03
    adc #1
    and #$03            ; keep animation bits
    sta $8f
    lda $81
    and #$fc            ; mask off the animation bits
    ora $8f
    sta ($74),y
    rts

move_enemy_next_direction: .byte $04, $0c, $00, $08

move_enemy:             ; $74,$75=character address

    lda #0
    sta $8d             ; vertical motion value (0=no motion; 1=up; 2=down)
    lda #0
    sta $8e             ; horizontal motion value (0=no motion; 1=left; 2=right)

    lda ($74),y         ; read the enemy number (Y should be zero)
    and #$10
    beq move_enemy_homing
    clc

    ; This enemy is a non-homing enemy.

    jsr unplot_character    ; unplot now before we change the sprite used

    ldy #1
    lda ($74),y
    and #$f0
    cmp #$f0
    bne move_enemy_set_direction
    clc

    ldy #1
    lda ($74),y
    and #$0c
    ror
    ror
    tax
    lda move_enemy_next_direction,x
    sta ($74),y

    move_enemy_set_direction:
    clc

    ldy #1
    lda ($74),y
    sta $7b

    adc #$10
    sta ($74),y
    clc

    lda $7b
    and #$04
    ror
    ror
    adc #1
    sta $8e

    lda $7b
    and #$08
    ror
    ror
    ror
    adc #1
    sta $8d

    jmp move_enemy_with_direction

    move_enemy_homing:

    ldy #2
    lda ($74),y         ; y
    cmp $5282           ; player y
    bmi move_enemy_downwards
    bne move_enemy_upwards

    ldy #3
    lda ($74),y         ; dy
    cmp $5283           ; player y
    beq move_enemy_horizontally
    bpl move_enemy_upwards

    move_enemy_downwards:
    lda #2
    sta $8d
    jmp move_enemy_horizontally

    move_enemy_upwards:
    lda #1
    sta $8d
    ;jmp move_enemy_horizontally

    move_enemy_horizontally:
    ldy #4
    lda ($74),y         ; x
    cmp $5284           ; player x
    bmi move_enemy_rightwards
    bne move_enemy_leftwards

    ldy #5
    lda ($74),y         ; dx
    cmp #0
    beq move_enemy_with_direction_unplot
    bpl move_enemy_leftwards

    move_enemy_rightwards:
    lda #2
    sta $8e
    jmp move_enemy_with_direction_unplot

    move_enemy_leftwards:
    lda #1
    sta $8e

    move_enemy_with_direction_unplot:
    clc

    jsr unplot_character

    move_enemy_with_direction:
    clc

    lda $8e
    cmp #1
    bne move_enemy_not_left
    jsr move_enemy_left
    clc
    jmp move_enemy_not_right

    move_enemy_not_left:
    lda $8e
    cmp #2
    bne move_enemy_not_right
    jsr move_enemy_right
    clc

    move_enemy_not_right:
    lda $8d
    cmp #1
    bne move_enemy_not_up
    jsr move_enemy_up
    clc
    jmp move_enemy_toggle

    move_enemy_not_up:
    lda $8d
    cmp #2
    bne move_enemy_toggle
    jsr move_enemy_down

    move_enemy_toggle:
    clc
    jsr move_enemy_animate
    jmp plot_character      ; optimise away the rts

    move_enemy_exit:
    clc
    rts

create_explosion:           ; X=y, Y=x

    lda #3
    sta $52a4
    lda #4
    sta $52a5
    txa
    sta $52a6
    lda #1
    sta $52a7
    tya
    sta $52a8
    lda #0
    sta $52a9
    rts

move_projectile_left:

    lda $528b
    cmp #0
    beq move_projectile_left_check_x

    dec $528b
    clc
    rts

    move_projectile_left_check_x:

    lda $528a
    cmp #0
    bne move_projectile_left_in_room
    jmp move_projectile_left_exit

    move_projectile_left_in_room:
    tay
    dey                         ; x - 1
    ldx $5288                   ; y
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the left

    cmp #0
    bne move_projectile_left_wall

    lda $5289                   ; dy
    cmp #3
    bmi move_projectile_allow_left

    clc                         ; dy > 2 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the left
    inx                         ; y += 1

    cmp #0
    bne move_projectile_left_wall

    move_projectile_allow_left:

    sty $528a       ; x
    lda #3
    sta $528b       ; dx = 3

    clc
    rts

    move_projectile_left_wall:  ; the projectile hit a wall
    clc

    lda $5287                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_left

    cmp #2
    bne move_projectile_left_not_boomerang

    lda $5287
    and #$0f
    cmp #8
    bpl move_projectile_left_exit

    ldx $577f               ; weapon counter
    ora boomerang_horizontal,x
    sta $5287
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_left_not_boomerang:

    cmp #6                          ; type 3 can destroy certain walls
    bne move_projectile_left_exit

    lda ($70),y                 ; load the tile to the left
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_left_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$a4
    sta $74
    lda #$52
    sta $75
    jsr plot_character

    ldx #0
    jsr play_sound

    lda #16                     ; prevent the player from firing a new
    sta $578d                   ; projectile until the explosion has finished

    move_projectile_left_exit:
    sec
    rts

boomerang_horizontal: .byte $28, $38

move_projectile_right:

    ; Fire right.

    lda $528b
    cmp #2
    beq move_projectile_right_check_x
    cmp #3
    beq move_projectile_right_tile

    inc $528b
    clc
    rts

    move_projectile_right_check_x:

    lda $528a       ; x
    cmp #9
    bne move_projectile_right_not_edge
    jmp move_projectile_right_exit

    move_projectile_right_not_edge:
    clc
    tay
    iny                         ; x + 1
    ldx $5288                   ; y
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_projectile_right_wall

    lda $5289                   ; dy
    cmp #3
    bmi move_projectile_allow_right

    clc                         ; dy > 2 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right
    inx                         ; y += 1

    cmp #0
    bne move_projectile_right_wall

    move_projectile_allow_right:

    inc $528b       ; dx
    clc
    rts

    move_projectile_right_tile:

    inc $528a       ; x
    lda #0
    sta $528b       ; dx
    clc
    rts

    move_projectile_right_wall:  ; the projectile hit a wall
    clc

    lda $5287                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_right

    cmp #2
    bne move_projectile_right_not_boomerang

    lda $5287
    and #$0f
    cmp #8
    bpl move_projectile_right_exit

    ldx $577f               ; weapon counter
    ora boomerang_horizontal,x
    sta $5287
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_right_not_boomerang:

    cmp #6                      ; type 3 can destroy certain walls
    bne move_projectile_right_exit

    lda ($70),y                 ; load the tile to the right
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_right_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$a4
    sta $74
    lda #$52
    sta $75
    jsr plot_character

    ldx #0
    jsr play_sound

    lda #16                     ; prevent the player from firing a new
    sta $578d                   ; projectile until the explosion has finished

    move_projectile_right_exit:
    sec
    rts

move_projectile_up:

    lda $5289           ; read dy
    cmp #0
    beq move_projectile_up_check_y

    dec $5289
    clc
    rts
    
    move_projectile_up_check_y:     ; Check the y offset.

    lda $5288
    cmp #0
    bne move_projectile_up_not_edge
    jmp move_projectile_up_exit

    move_projectile_up_not_edge:
    tax                         ; use the y offset as an index
    dex                         ; y - 1
    ldy $528a                   ; load the x offset
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_projectile_up_wall

    lda $528b                   ; dx
    cmp #3
    bmi move_projectile_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_projectile_up_wall

    move_projectile_allow_up:
    txa
    sta $5288               ; store the new room y offset
    lda #3
    sta $5289               ; dy = 3

    clc
    rts

    move_projectile_up_wall:    ; the projectile hit a wall
    clc

    lda $5287                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_up

    cmp #2
    bne move_projectile_up_not_boomerang

    lda $5287
    and #$0f
    cmp #8
    bpl move_projectile_up_exit

    ldx $577f               ; weapon counter
    ora boomerang_vertical,x
    sta $5287
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_up_not_boomerang:

    cmp #6                      ; type 3 can destroy certain walls
    bne move_projectile_up_exit

    lda ($70),y                 ; load the tile above
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_up_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$a4
    sta $74
    lda #$52
    sta $75
    jsr plot_character

    ldx #0
    jsr play_sound

    lda #16                     ; prevent the player from firing a new
    sta $578d                   ; projectile until the explosion has finished

    move_projectile_up_exit:
    sec
    rts

boomerang_vertical: .byte $08, $18

move_projectile_down:

    lda $5289                   ; read dy
    cmp #2
    beq move_projectile_down_check_y
    cmp #3
    beq move_projectile_down_tile

    inc $5289                   ; 0 <= dy < 3
    clc
    rts

    move_projectile_down_check_y:  ; Check the y offset.

    lda $5288
    cmp #9
    bne move_projectile_down_in_room
    jmp move_projectile_down_exit

    move_projectile_down_in_room:
    clc
    tax
    inx                         ; y + 1
    ldy $528a                   ; load the x offset
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_projectile_down_wall

    lda $528b                   ; dx
    cmp #3
    bmi move_projectile_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_projectile_down_wall

    move_projectile_allow_down:

    inc $5289                   ; update dy
    clc
    rts

    move_projectile_down_tile:

    inc $5288                   ; store the new room y offset
    lda #0
    sta $5289                   ; dy = 0
    clc
    rts

    move_projectile_down_wall:  ; the projectile hit a wall
    clc

    lda $5287                   ; type 2 can pass through walls
    and #$06
    cmp #4
    beq move_projectile_allow_down

    cmp #2
    bne move_projectile_down_not_boomerang

    lda $5287
    and #$0f
    cmp #8
    bpl move_projectile_down_exit

    ldx $577f               ; weapon counter
    ora boomerang_vertical,x
    sta $5287
    clc
    rts                     ; exit without moving or registering a collision

    move_projectile_down_not_boomerang:

    cmp #6                      ; type 3 can destroy certain walls
    bne move_projectile_down_exit

    lda ($70),y                 ; load the tile below
    cmp #1                      ; decoration can be destroyed
    bne move_projectile_down_exit
    clc

    lda #0
    sta ($70),y
    
    ; X=y, Y=x
    jsr create_explosion
    jsr plot_blank_xy           ; corrupted X

    lda #$a4
    sta $74
    lda #$52
    sta $75
    jsr plot_character

    ldx #0
    jsr play_sound

    lda #16                     ; prevent the player from firing a new
    sta $578d                   ; projectile until the explosion has finished

    move_projectile_down_exit:
    sec
    rts

move_projectile_animate:

    lda $5287
    eor #1
    sta $5287
    rts

move_projectile:

    lda $5286
    cmp #0
    bne move_projectile_move
    jmp move_projectile_exit

    move_projectile_move:
    clc

    lda #$86
    sta $74
    lda #$52
    sta $75
    jsr unplot_character

    move_projectile_after_unplot:

    lda $5287
    and #$30            ; direction

    cmp #0
    bne move_projectile_not_left

    jsr move_projectile_left
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_left:
    cmp #$10
    bne move_projectile_not_right

    jsr move_projectile_right
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_right:
    cmp #$20
    bne move_projectile_not_up

    jsr move_projectile_up
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_up:
    cmp #$30
    bne move_projectile_toggle

    jsr move_projectile_down
    bcs move_projectile_destroy

    move_projectile_toggle:

    jsr projectile_collide
    bcs move_projectile_destroy

    jsr move_projectile_animate

    lda #$86
    sta $74
    lda #$52
    sta $75
    jmp plot_character          ; optimise away the rts

    move_projectile_destroy:
    clc

    ldy #0
    lda ($74),y ; type
    cmp #8
    bmi move_projectile_no_enemy_collision

    and #$70            ; increase the player's score
    lsr
    lsr
    lsr
    adc #2
    sta $70
    jsr add_score
    jmp move_projectile_create_explosion

    move_projectile_no_enemy_collision:

    cmp #4          ; items can be destroyed as well
    bne move_projectile_no_item_collision

    ldy #1          ; but not keys
    lda ($74),y
    cmp #4          ; even the mace is stopped by a key
    beq move_projectile_remove_projectile
    clc

    jsr remove_room_item

    move_projectile_create_explosion:

    ; Unplot the item/enemy and replace it with an explosion.

    jsr unplot_character

    lda #3      ; explosion
    ldy #0
    sta ($74),y

    lda #4
    ldy #1
    sta ($74),y

    jsr plot_character

    ; Play a sound.
    ldx #0
    jsr play_sound

    move_projectile_no_item_collision:

    lda $5287       ; type 2 projectiles pass through everything
    and #$06
    cmp #4
    bne move_projectile_remove_projectile

    ; Ideally, we would have recorded if the projectile left the screen so
    ; that we don't perform these checks again here, but it would just add
    ; overhead to the normal movement routines for the other weapons.

    lda $5288       ; y
    cmp #0
    beq move_projectile_remove_projectile
    cmp #9
    beq move_projectile_remove_projectile

    lda $528a       ; x
    cmp #0
    beq move_projectile_remove_projectile
    cmp #9
    beq move_projectile_remove_projectile

    clc
    lda #$86
    sta $74
    lda #$52
    sta $75

    jsr plot_character
    jmp move_projectile_exit

    move_projectile_remove_projectile:

    lda #0              ; remove the projectile from the character list
    sta $5286

    move_projectile_exit:
    clc
    rts

emerge_characters:

    lda #$8c            ; set the character address
    sta $74
    lda #$52
    sta $75

    emerge_characters_loop:

        ldy #0
        lda ($74),y
        cmp #0
        bne emerge_characters_next

        jmp emerge_character    ; optimise away the rts

        emerge_characters_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$a4
        bpl emerge_characters_exit
        sta $74
        jmp emerge_characters_loop

    emerge_characters_exit:
    clc
    rts

enemy_slots: .byte 0, 6, 12, 18

move_characters:

    lda #$8c            ; set the character address
    sta $74
    lda #$52
    sta $75

    lda $578e           ; read a value from 0 to 3 from the motion counter
    and #3
    tax
    lda enemy_slots,x   ; look up the corresponding slot in the character list
    adc $74
    sta $74             ; update the character address

    move_characters_loop:
    
        ldy #0
        lda ($74),y
        cmp #3
        bne move_characters_not_emerge_explode

        jsr emerge_explode
        jmp move_characters_next

        move_characters_not_emerge_explode:
        cmp #8
        bmi move_characters_next

        jsr move_enemy

        move_characters_next:
        clc

        lda $74                     ; for the last enemy, check the next slot
        cmp #$9e                    ; for the presence of an explosion
        bne move_characters_endloop ; otherwise leave the loop (only performing
        clc                         ; one iteration)

        adc #6
        sta $74
        jmp move_characters_loop

    move_characters_endloop:
    clc

    ; Check collisions with the player.

    jsr player_collide
    bcs move_characters_collisions
    jmp move_characters_exit

    move_characters_collisions:
    clc

    ldy #0
    lda ($74),y ; type
    cmp #8
    bpl move_character_destroy_enemy

    ; Unplot the item.
    jsr unplot_character

    ; Remove it from the item table.
    jsr remove_room_item

    lda #0      ; remove the item from the character list
    ldy #0
    sta ($74),y

    iny
    lda ($74),y         ; get the item type

    sta $8d             ; temporarily store A and increase the score
    tax
    lda item_scores,x
    sta $70
    jsr add_score
    lda $8d

    ; Check the item type.
    cmp #8
    bmi move_characters_not_health

    lda #20
    sta $70
    jsr add_strength
    clc

    ldx #2
    jsr play_sound

    rts

    move_characters_not_health:
    cmp #5
    bmi move_characters_not_treasure

    ldx #2
    jsr play_sound

    clc
    rts

    move_characters_not_treasure:
    cmp #4
    bmi move_characters_not_key

    ; Key - update the item/player flags byte.
    lda $5780
    ora #$01
    sta $5780
    clc

    ldx #3
    jsr play_sound

    rts

    move_characters_not_key:

    ; Update the player's weapon.
    asl
    sta $5789
    clc

    ldx #2
    jsr play_sound

    rts

    move_character_destroy_enemy:
    
    ; Unplot the enemy and replace it with an explosion.

    jsr unplot_character

    lda #3      ; explosion
    ldy #0
    sta ($74),y

    lda #4
    ldy #1
    sta ($74),y

    jsr plot_character

    ; Reduce the player's strength.

    ldx #1
    jsr play_sound

    lda #1
    sta $70
    jmp reduce_strength ; optimise away the rts

    move_characters_exit:
    clc
    rts

remove_room_item:

    ldx $5782                       ; current room row number
    lda eleven_times_table,x
    adc $5783                       ; current room column number
    tax
    lda #$80    ; store a value with the top bit set instead of zero because we
    sta $5200,x ; have visited this room if we can collect the object within it
    clc
    rts

item_scores:     .byte $1,$4,$9,$16, $50,$20,$5,$10,$40
score_vdu_bytes: .byte 1,1,31   ; reversed
score_digits:    .byte "0123456789"

add_score:      ; $70=score to add

    sed
    lda $5786
    adc $70
    sta $5786
    lda $5787
    adc #0
    sta $5787
    lda $5788
    adc #0
    sta $5788
    cld

write_score:

    lda #$86
    sta $70
    lda #$57
    sta $71

    ldx #2
    write_score_vdu_bytes:
        lda score_vdu_bytes,x
        jsr $ffee
        dex
        bpl write_score_vdu_bytes

write_score_digits:     ; $70,$71=address of score bytes

    ldy #2
    write_score_loop:

        lda ($70),y
        lsr
        lsr
        lsr
        lsr
        tax
        lda score_digits,x
        jsr $ffee

        lda ($70),y
        and #$0f
        tax
        lda score_digits,x
        jsr $ffee

        dey
        bpl write_score_loop

    clc
    rts

strength_units:          .byte $00,$88,$cc,$ee

add_strength:   ; $70=strength to add

    ; Divide the initial strength by 4 to determine which half character to
    ; start plotting at, and multiply by 8 to get the address. The net result
    ; is to mask off the bottom two bits and shift left once.
    lda $5784
    and #$fc
    sta $71     ; strength rounded down to a multiple of four units
    asl
    clc
    tay

    lda $5784
    adc $70
    cmp #65
    bmi add_strength_update

    lda #64

    add_strength_update:
    clc
    sta $5784   ; the final strength

    sec
    sbc $71
    clc
    tax         ; the number of units to add between the rounded original
                ; strength and the final strength

    lda #$f3    ; the start of the strength bar
    sta $72
    lda #$59
    sta $73

    cpx #4
    bmi add_strength_loop_extra

    add_strength_loop:

        clc
        lda #$ff
        sta ($72),y

        tya
        adc #8
        tay

        txa
        sec
        sbc #4
        clc
        tax

        cmp #4
        bpl add_strength_loop

    add_strength_loop_extra:
    cpx #0
    beq add_strength_exit

    ; For any remaining units in excess of the multiples of four units, plot
    ; the appropriate byte.
    lda $5784
    and #3
    tax

    lda strength_units,x
    sta ($72),y

    add_strength_exit:
    clc
    rts

reduce_strength:    ; $70=strength to remove

    lda $5784
    tax
    sec
    sbc $70
    bpl reduce_strength_update

    lda #0

    reduce_strength_update:
    clc
    sta $5784

    ; Divide the final strength by 4 to determine which half character to
    ; plot, and multiply by 8 to get the address. The net result is to mask off
    ; the bottom two bits and shift left once.
    and #$fc
    asl
    tay

    lda #$f3    ; the start of the strength bar
    sta $70
    lda #$59
    sta $71

    lda $5784
    and #3
    tax
    lda strength_units,x
    sta ($70),y

    lda $5784
    cmp #0
    bne reduce_strength_exit

    lda $5780       ; the player ran out of strength
    ora #$40
    sta $5780

    lda #64         ; reset the delay counter
    sta $5785

    lda #$80        ; unplot the player
    sta $74
    lda #$52
    sta $75

    jsr unplot_character

    lda #8          ; change the player's direction to the demise animation
    sta $5281

    jsr plot_character
    jmp destroy_enemies ; optimise away the rts

    reduce_strength_exit:
    clc
    rts

destroy_enemies:

    lda #$8c
    sta $74
    lda #$52
    sta $75

    destroy_enemies_loop:

        ldy #0
        lda ($74),y
        cmp #8
        bmi destroy_enemies_not_enemy

        jsr unplot_character

        lda #3          ; emerge/explosion
        ldy #0
        sta ($74),y

        iny
        lda #4          ; explosion
        sta ($74),y

        jsr plot_character
        jmp destroy_enemies_not_emerging_enemy

        destroy_enemies_not_enemy:
        cmp #3
        bne destroy_enemies_not_emerging_enemy

        jsr unplot_character

        iny             ; whether emerging or exploding, ensure that the enemy
        lda ($74),y     ; is now exploding
        ora #4
        sta ($74),y

        jsr plot_character

        destroy_enemies_not_emerging_enemy:
        clc
        lda $74
        adc #6
        sta $74
        cmp #$a4
        bmi destroy_enemies_loop

    clc
    rts

remove_characters:

    ; Clear the character table.

    ldx #6
    remove_characters_loop:
        lda #0
        sta $5280,x
        txa
        adc #6
        tax
        cpx #$2a
        bmi remove_characters_loop

    rts

; The player collision masks use bits to represent where the player is in a
; tile. See the collisions.txt file for more information.

; Player is above, enemy is below, checking the overlap in the lower tile.
player_collision_mask_above: .byte $00, $c0, $f0, $fc

projectile_collision_mask_above: .byte $00, $00, $00, $80

; Player and enemy share the same tile or player is on the tile below.
player_collision_mask_below:  .byte $ff, $3f, $0f, $03

projectile_collision_mask_below: .byte $e0, $38, $e0, $03

; Player is above or on the same tile, enemy is below, checking the overlap in
; the lower tile.
enemy_collision_mask_above:  .byte $f8, $3f, $0f, $03

; Enemy is above, player is below, checking the overlap in the lower tile.
enemy_collision_mask_below: .byte $00, $00, $c0, $f0

; Player is to the left, enemy is to the right, checking the overlap in the
; right hand tile.
player_collision_mask_left:
projectile_collision_mask_left: .byte $00, $00, $00, $08

; Player and enemy share the same tile or player is on the tile to the right.
player_collision_mask_right:
projectile_collision_mask_right: .byte $0c, $06, $03, $01

; Player is to the left, enemy is to the right or on the same tile, checking
; the overlap in the right hand tile.
enemy_collision_mask_left:  .byte $0f, $07, $03, $01

; Enemy is to the left, player is to the right, checking the overlap in the
; right hand tile.
enemy_collision_mask_right: .byte $00, $08, $0c, $0e

player_collide:

    lda $5282                           ; player y
    sta $8a
    lda $5284                           ; player x
    sta $8b

    ldx $5283                           ; player dy
    lda player_collision_mask_above,x
    sta $86
    lda player_collision_mask_below,x
    sta $88
    ldx $5285                           ; player dx
    lda player_collision_mask_left,x
    sta $87
    lda player_collision_mask_right,x
    sta $89

    jmp collide ; optimise away the rts

projectile_collide:

    lda $5288                           ; projectile y
    sta $8a
    lda $528a                           ; projectile x
    sta $8b

    ldx $5289                           ; projectile dy
    lda projectile_collision_mask_above,x
    sta $86
    lda projectile_collision_mask_below,x
    sta $88
    ldx $528b                           ; projectile dx
    lda projectile_collision_mask_left,x
    sta $87
    lda projectile_collision_mask_right,x
    sta $89

    ; Run on into the next routine.

collide:

    lda #$8c            ; set the character address
    sta $74
    lda #$52
    sta $75

    collide_loop:

        ldy #0
        lda ($74),y         ; type
        cmp #4
        bpl collide_check

        jmp collide_next

        collide_check:

        ldy #2
        lda ($74),y         ; y
        sec
        sbc $8a             ; y - player/projectile y
        beq check_collide_y_equal
        cmp #1
        beq check_collide_y_greater
        cmp #255
        beq check_collide_y_less

        jmp collide_next

        check_collide_y_equal:
        ; The enemy is on the same tile as the player/projectile so look at the
        ; collision on their common tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_above,x
        and $88                             ; player/projectile mask below
        bne check_collide_x

        jmp collide_next

        check_collide_y_greater:
        ; The enemy is on the tile below the player/projectile so look at the
        ; collision on the enemy's tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_above,x
        and $86                             ; player mask above
        bne check_collide_x

        jmp collide_next

        check_collide_y_less:
        ; The enemy is on the tile above the player/projectile so look at the
        ; collision on the player's tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_below,x
        and $88                             ; player mask below
        bne check_collide_x

        jmp collide_next

        check_collide_x:
        ldy #4
        lda ($74),y         ; x
        sec
        sbc $8b             ; x - player/projectile x
        beq check_collide_x_equal
        cmp #1
        beq check_collide_x_greater
        cmp #255
        beq check_collide_x_less

        jmp collide_next

        check_collide_x_equal:
        ; The enemy is on the same tile as the player/projectile so look at the
        ; collision on their common tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_left,x
        and $89                             ; player mask right
        bne check_collide_destroy

        jmp collide_next

        check_collide_x_greater:
        ; The enemy is the tile to the right of the player/projectile so look
        ; at the collision on the enemy's tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_left,x
        and $87                             ; player mask left
        bne check_collide_destroy

        jmp collide_next

        check_collide_x_less:
        ; The enemy is the tile to the left of the player/projectile so look at
        ; the collision on the player's tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_right,x
        and $89                             ; player mask right
        bne check_collide_destroy

        collide_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$a4
        bpl collide_exit
        sta $74
        jmp collide_loop

    check_collide_destroy:

    sec         ; set the carry flag to inform the caller that the
    rts         ; player/projectile should be destroyed

    collide_exit:
    clc
    rts

blank_screen:
    lda #1
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #2
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #3
    sta $70
    lda #0
    sta $71
    ; Run on into set_palette.

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $578b
    lda $71
    sta $578c
    lda #0
    sta $578d
    sta $578e
    sta $578f

    lda #$c         
    ldx #$8b
    ldy #$57
    jsr $fff1
    rts

sounds_low:  .byte <explosion_sound, <damage_sound, <item_sound, <key_sound, <note_sound, <emerge_sound
sounds_high: .byte >explosion_sound, >damage_sound, >item_sound, >key_sound, >note_sound, >emerge_sound

explosion_sound: .byte 1,0, 1,0, 60,0, 2,0
damage_sound:    .byte 1,0, 2,0, 40,0, 4,0
item_sound:      .byte $13,0, 3,0, 32,0, 3,0
key_sound:       .byte $13,0, 4,0, 50,0, 5,0
note_sound:      .byte $13,0, 241,255
note_pitch:      .byte 0,0
note_duration:   .byte 4,0
emerge_sound:    .byte 2,0, 3,0, 0,0, 2,0

play_note:      ; A=pitch, Y=duration

    sta note_pitch
    sty note_duration
    ldx #4
    ; Run on into the next routine.

play_sound:     ; X=sound number

    lda sounds_high,x
    tay
    lda sounds_low,x
    tax
    lda #7
    jsr $fff1

    rts

copy_title_up:

    lda #$00
    sta $70
    lda #$18
    sta $71

    lda #$a0
    sta $72
    lda #$5a
    sta $73

    ldx #5
    ; Run on into the next routine.

copy_title:

    copy_title_loop1:

        ldy #0
        copy_title_loop2:

            lda ($70),y
            sta ($72),y
            iny
            cpy #0
            bne copy_title_loop2

        clc
        lda $72
        adc #$40
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        lda $71
        adc #$01
        sta $71
        clc

        dex
        bpl copy_title_loop1

    rts

copy_completed_screen_up:

    lda #$00
    sta $70
    lda #$0f
    sta $71

    lda #$60
    sta $72
    lda #$5e
    sta $73

    ldx #8
    jmp copy_title  ; optimise away the rts

init:
    jsr cls     ; clear the text window

    lda #26     ; unset the text window
    jsr $ffee

    ; Define the default high scores.
    ldy #0
    lda #$80
    sta $70
    lda #$51
    sta $71
    lda #$16
    sta $72

    ldx #0
    init_define_high_scores_loop:

        lda #0
        sta ($70),y
        iny
        lda $72
        sta ($70),y
        iny
        lda #0
        sta ($70),y

        iny
        init_define_high_score_name_loop:

            lda high_score_default_name1,x
            sta ($70),y
            iny
            inx
            cpx #9
            beq init_define_high_scores_next
            cpx #18
            bne init_define_high_score_name_loop

        ldx #0
        init_define_high_scores_next:

        sed
        lda $72
        sec
        sbc #2
        sta $72
        cld
        clc

        cpy #96
        bne init_define_high_scores_loop

    ; Disable joystick support.
    lda #0
    sta $577e

    rts

high_score_default_name1: .byte "RETRO    "
high_score_default_name2: .byte " SOFTWARE"

title_vdu_bytes:    .byte 17,2, 31,7,28, "to play"
input_message:      .byte 17,2, 31,1,27, "Press SPACE / FIRE"
title_vdu_bytes1:   .byte 17,3, 31,1,30, "Copyright (c) 2011"
title_vdu_bytes2:   .byte 17,3, 31,1,30, "   David Boddie   "
title_vdu_bytes3:   .byte 17,1, 31,1,30, "for Retro Software"
title_vdu_bytes4:   .byte 17,3, 31,1,30, "GNU GPL 3 or later"

set_standard_palette:

    lda #1
    sta $70
    lda #1
    sta $71
    jsr set_palette

    jmp set_core_palette    ; optimise away the rts

complete_palette_bytes: .byte 2,4, 3,5, 1,4, 3,3, 2,2

set_complete_palette:

    lda #0
    sta $80
    lda #25
    sta $81

    set_complete_palette_loop:

        jsr wait_for_vsync

        dec $81
        lda $81
        cmp #0
        bne set_complete_palette_loop

        lda #25
        sta $81

        ldx $80
        lda complete_palette_bytes,x
        sta $70
        inx 
        lda complete_palette_bytes,x
        sta $71
        inx
        stx $80
        jsr set_palette

        lda $80
        cmp #10
        bne set_complete_palette_loop

    rts

set_hidden_palette:

    lda #1
    sta $70
    lda #0
    sta $71
    jsr set_palette

    ; Run on into the next routine.

set_core_palette:

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

show_title:

    jsr set_standard_palette

    ldx #0
    write_title_text_loop:
        lda title_vdu_bytes,x
        jsr $ffee
        inx
        cpx #12
        bmi write_title_text_loop

    jsr show_input_message

    ; Show the title.
    jsr copy_title_up

    ; Show the high scores.

    jsr colour1

    lda #$80
    sta $70
    lda #$51
    sta $71

    lda #8
    sta $80

    show_title_high_scores_loop:

        lda #31
        jsr $ffee
        lda #2
        jsr $ffee
        lda $80
        adc #2
        sta $80
        clc
        jsr $ffee

        jsr write_score_digits

        lda #32
        jsr $ffee

        ldx #8
        ldy #3
        show_title_high_scores_vdu_loop2:

            lda ($70),y
            cmp #32
            bmi ignore_char
            cmp #123
            bpl ignore_char
            jsr $ffee

            ignore_char:
            iny
            dex
            bpl show_title_high_scores_vdu_loop2

        lda $70
        adc #12
        sta $70
        cmp #$e0
        bne show_title_high_scores_loop

    lda #0          ; message counter
    sta $72

    show_title_wait_loop:

        lda #150
        sta $5785

        ldx $72
        ldy #22
        show_title_wait_message_loop:

            lda title_vdu_bytes1,x
            jsr $ffee
            inx
            dey
            bpl show_title_wait_message_loop

        cpx #92
        beq show_title_wait_reset_offset

        txa
        sta $72
        jmp show_title_wait_inner_loop

        show_title_wait_reset_offset:
        lda #0
        sta $72

        show_title_wait_inner_loop:
        jsr wait_for_vsync

        dec $5785
        beq show_title_wait_loop

        show_title_wait_loop_no_update:
        lda #128
        ldx #0
        jsr $fff4
        cpx #0              ; fire button pressed?
        beq show_title_no_joystick
        
        lda #1              ; enable joystick support
        sta $577e
        jmp show_title_exit

        show_title_no_joystick:
        ldx #157            ; SPACE
        jsr check_key
        cpy #255
        bne show_title_wait_inner_loop

    lda #0              ; disable joystick support
    sta $577e

    show_title_exit:
    clc
    rts

show_input_message:

    ldx #0
    show_input_message_loop:

        lda input_message,x
        jsr $ffee
        inx
        cpx #23
        bne show_input_message_loop
    
    rts

wait_for_vsync:

    lda #19
    jmp $fff4   ; optimise away the rts

game_over_vdu_bytes: .byte 28,4,17,15,15, 12, 26, 31,4,15, 17,2, "The journey", 31,9,17, "is over"

delay:

    delay_loop:

        jsr wait_for_vsync
        dec $5785
        bne delay_loop

    rts

show_game_over:

    lda #128
    sta $5785
    jsr delay

    ldx #0
    write_game_over_text_loop:
        lda game_over_vdu_bytes,x
        jsr $ffee
        inx
        cpx #33
        bmi write_game_over_text_loop

    lda #192
    sta $5785
    jsr delay

    rts

end_of_level_bytes1:  .byte 31,1,3, 17,3, "Exploration bonus", 31,11,5, "x 9"
end_of_level_bytes2:  .byte 31,0,28, 17,2, "My journey continues"

show_end_of_level_screen:

    ; Draw a decorative room.

    jsr make_empty_room

    ldx #5
    end_of_level_h_walls_loop:

        lda #3
        sta $57b2,x
        sta $57e4,x
        dex
        bpl end_of_level_h_walls_loop

    ldx #30
    end_of_level_v_walls_loop:

        lda #3
        sta $57bc,x
        sta $57c1,x
        txa
        sec
        sbc #10
        tax
        bpl end_of_level_v_walls_loop

    jsr plot_room_tiles
    jsr set_standard_palette

    ldx #0
    end_of_level_text_loop1:

        lda end_of_level_bytes1,x
        jsr $ffee
        inx
        cpx #28
        bne end_of_level_text_loop1

    ; Count the number of rooms explored.
    ldx #0
    lda #0
    sta $8d
    sta $8e
    end_of_level_room_count_loop:

        lda $5200,x
        and #$80
        beq end_of_level_room_count_loop_next

        sed
        lda $8d
        adc #1
        sta $8d
        lda $8e
        adc #0
        sta $8e
        cld
        clc

        end_of_level_room_count_loop_next:
        inx
        cpx #121
        bne end_of_level_room_count_loop

    ; Position the player so that we can perform an animation.
    jsr position_player_set_up_plotting

    lda $8d
    sta $70
    lda $8e
    sta $71
    jsr write_bonus

    lda #0      ; reset motion counter
    sta $578e

    show_end_of_level_bonus_loop:

        jsr wait_for_vsync

        clc
        lda $578e
        and #15
        bne end_of_level_no_animation

        ; Animate the player.

        jsr reset_unplot_buffer
        jsr reset_plot_buffer

        ; $74,$75 should be unchanged
        jsr unplot_character

        lda $5281
        eor #1
        sta $5281
        jsr plot_character

        jsr plot_buffer

        end_of_level_no_animation:
        clc
        lda $578e
        and #3
        bne end_of_level_no_countdown

        ; Transfer the bonus to the score.

        sed
        sec
        lda $8d
        sbc #1
        sta $8d
        sta $70
        lda $8e
        sbc #0
        sta $8e
        sta $71
        cld
        clc

        jsr write_bonus

        lda #9
        sta $70
        jsr add_score

        lda $8d
        and #$3f
        asl
        ldy #1
        jsr play_note

        end_of_level_no_countdown:
        inc $578e   ; update motion counter
        clc

        lda $8d
        cmp #0
        bne show_end_of_level_bonus_loop

        lda $8e
        cmp #0
        bne show_end_of_level_bonus_loop

    lda #64    ; initialise delay counter
    sta $5785
    jsr delay

    ldx #0
    end_of_level_text_loop2:

        lda end_of_level_bytes2,x
        jsr $ffee
        inx
        cpx #25
        bne end_of_level_text_loop2

    lda $578a
    cmp #3
    bpl show_end_of_level_screen_exit

    lda #192    ; initialise delay counter
    sta $5785
    jsr delay

    show_end_of_level_screen_exit:
    rts

level_bonus_vdu_bytes: .byte 5,6,31, 1,17  ; reversed

write_bonus:        ; $70,$71=value
                    ; $72,$73=address of VDU codes

    ldx #4
    write_bonus_vdu_bytes:

        lda level_bonus_vdu_bytes,x
        jsr $ffee
        dex
        bpl write_bonus_vdu_bytes

    ldy #1
    write_bonus_loop:

        tya
        tax         ; temporary

        lda $70,x
        sta $80
        lsr
        lsr
        lsr
        lsr
        tax
        lda score_digits,x
        jsr $ffee

        lda $80
        and #$0f
        tax
        lda score_digits,x
        jsr $ffee

        dey
        bpl write_bonus_loop

    clc
    rts

position_player_set_up_plotting:

    jsr reset_player_position
    jsr remove_characters

    jsr reset_unplot_buffer
    jsr reset_plot_buffer

    ; Run on into the next routine.

plot_the_player:

    lda #$80        ; plot the player
    sta $74
    lda #$52
    sta $75
    jsr plot_character

    jsr plot_buffer
    rts

complete_game_vdu_bytes1: .byte 12
complete_game_vdu_bytes2: .byte 17,3, 31,2,20, "Congratulations!"
complete_game_vdu_bytes3: .byte 17,2, 31,1,22, "Now journey onward"
complete_game_vdu_bytes4: .byte 17,2, 31,1,24, "to a new adventure"

show_complete_game:

    jsr blank_screen

    ldx #0
    show_complete_game_vdu_loop:

        lda complete_game_vdu_bytes1,x
        jsr $ffee
        inx
        cpx #68
        bne show_complete_game_vdu_loop

    jsr copy_completed_screen_up

    jsr set_complete_palette

    lda #255
    sta $5785

    show_complete_game_delay_loop:

        jsr wait_for_vsync

        dec $5785
        bne show_complete_game_no_message

        jsr colour1
        jsr show_input_message

        show_complete_game_no_message:

        lda #128
        ldx #0
        jsr $fff4
        cpx #0              ; fire button pressed?
        beq show_complete_game_no_joystick
        jmp show_complete_game_exit

        show_complete_game_no_joystick:

        ldx #157
        jsr check_key
        cpy #255
        bne show_complete_game_delay_loop

    show_complete_game_exit:
    clc
    rts

check_high_scores:

    ; Start at the bottom of the table, moving scores down as necessary, and
    ; write in the current score at the appropriate place.

    lda #$86    ; current score
    sta $70
    lda #$57
    sta $71

    lda #$80
    sta $72
    lda #$51
    sta $73

    check_high_scores_loop:

        ldy #2
        check_high_scores_digits_loop:

            lda ($72),y
            cmp ($70),y     ; existing score less than current score?
            bmi check_high_scores_move_down
            beq check_high_scores_digits_next   ; keep checking digits if equal
            jmp check_high_scores_next

            check_high_scores_digits_next:
            dey
            bpl check_high_scores_digits_loop

        check_high_scores_next:
        clc
        lda $72
        adc #12
        sta $72
        cmp #$e0
        bne check_high_scores_loop

    ; The player's score didn't make it into the high score table.
    rts

check_high_scores_move_down:    ; $70,$71=pointer to current score
                                ; $72,$73=pointer to old score

    ; The current score exceeded the existing entry. Make a note of the
    ; position in the high score table, insert the player's score, and take
    ; the old score

    lda $72     ; Record the position in the high score table of the
    sta $8d     ; player's score.
    lda $73
    sta $8e

    lda #$e0
    sta $74
    lda #$51
    sta $75

    ldy #0
    insert_blank_player_name_loop:

        cpy #3
        bpl insert_blank_player_name_score_only

        lda ($70),y
        jmp insert_blank_player_name_store

        insert_blank_player_name_score_only:
        lda #32

        insert_blank_player_name_store:
        sta ($74),y
        iny
        cpy #12
        bne insert_blank_player_name_loop

    check_high_scores_move_down_loop:

        ldy #0
        check_high_scores_copy_score_and_name:

            lda ($72),y ; swap the current score with the score in the table
            tax
            lda ($74),y
            sta ($72),y
            txa
            sta ($74),y
            iny
            cpy #12
            bne check_high_scores_copy_score_and_name

        clc
        lda $72
        adc #12
        sta $72
        cmp #$e0
        bne check_high_scores_move_down_loop

    ; Draw a decorative room.

    jsr set_hidden_palette

    jsr make_empty_room

    lda #3
    sta $76
    sta $77
    jsr draw_top_line
    jsr draw_bottom_line
    jsr draw_left_line

    lda #0
    sta $77
    jsr draw_right_line

    jsr plot_room_tiles

    ; Add text characters to the room.
    jsr colour3

    lda #3          ; x
    sta $70
    lda #6          ; y
    sta $71

    lda #65
    sta $72

    ldx #3
    plot_text_characters_loop:

        jsr print_xy

        lda $70
        adc #4
        sta $70

        dex
        bpl plot_text_characters_next

        lda #3
        sta $70
        lda $71
        adc #3
        sta $71

        ldx #3

        plot_text_characters_next:

        inc $72
        lda $72
        cmp #91
        bne plot_text_characters_loop

    lda #11
    sta $70
    lda #95         ; _ representing a space
    sta $72
    jsr print_xy

    lda #15
    sta $70
    lda #60         ; < representing delete
    sta $72
    jsr print_xy

    ; Put the player in the centre of the room.
    jsr position_player_set_up_plotting

    lda #0          ; reset motion counter
    sta $578e

    lda #0          ; not on a character
    sta $578d

    lda #0          ; reset the level number so that the correct tiles are used
    sta $578a

    lda #3          ; cursor position in the high score entry held in $8d,$8e
    sta $8f

    jsr set_standard_palette

    ldx #0
    high_score_vdu_loop:

        lda high_score_vdu_bytes,x
        jsr $ffee
        inx
        cpx #39
        bne high_score_vdu_loop

    high_score_entry_loop:

        jsr reset_unplot_buffer
        jsr reset_plot_buffer

        jsr move_player
        ; Check if the player leaves the room.
        bcc high_score_entry_check_position
        jmp high_score_entry_after_loop

        high_score_entry_check_position:

        lda $5285       ; dx
        cmp #2
        beq high_score_entry_maybe_aligned
        jmp high_score_entry_not_aligned

        high_score_entry_maybe_aligned:

        lda $5282       ; y
        tay
        cmp #8
        bpl high_score_entry_not_aligned

        lda $5284       ; x
        tax
        cmp #9
        beq high_score_entry_not_aligned
        and #1
        beq high_score_entry_not_aligned

        lda $5283       ; dy
        cmp #2
        bmi high_score_entry_aligned
        jmp high_score_entry_not_aligned

        lda $5282       ; y again (don't apply the touching rule to the bottom
        cmp #7          ;          row of characters)
        beq high_score_entry_not_aligned

        iny             ; we are really touching the character below

        high_score_entry_aligned:

        lda $578d
        cmp #1
        beq high_score_entry_next

        ; The player is aligned with a letter.
        txa
        sec
        sbc #1
        lsr
        sta $7e         ; record (x - 1) / 2

        tya             ; recall y
        sec
        sbc #1
        asl
        asl             ; (y - 1) * 4
        clc

        adc $7e         ; (y - 1) * 4 + (x - 1) / 2
        adc #65
        sta $7e         ; record the ASCII code

        cmp #91
        bmi insert_character

        cmp #92
        beq delete_character

        ; Insert a space.
        lda #32
        sta $7e

        insert_character:
        lda $8f
        cmp #12
        bpl high_score_entry_pressed

        tay             ; insert the character
        lda $7e
        sta ($8d),y
        jsr print_high_score_character

        inc $8f
        jmp high_score_entry_pressed

        delete_character:
        lda $8f
        cmp #4
        bmi high_score_entry_pressed

        cmp #12
        beq high_score_delete_previous_character

        tay
        lda #32         ; insert a space
        sta ($8d),y
        jsr print_high_score_character

        high_score_delete_previous_character:
        dec $8f
        lda $8f
        tay             ; insert a space
        lda #32
        sta ($8d),y
        jsr print_high_score_character

        high_score_entry_pressed:
        lda #1
        sta $578d
        jmp high_score_entry_next

        high_score_entry_not_aligned:
        lda #0
        sta $578d

        high_score_entry_next:

        jsr wait_for_vsync
        jsr plot_buffer

        jmp high_score_entry_loop

        inc $578e
        clc

    high_score_entry_after_loop:
    clc

    jsr cls
    jsr set_hidden_palette

    rts

high_score_vdu_bytes: .byte 17,1, 31,2,3, "Enter your name!", 17,3, 31,5,30, ">         <", 17,1

cls:
    lda #12
    jsr $ffee
    rts

colour1:
    lda #17
    jsr $ffee
    lda #1
    jsr $ffee
    rts

colour3:
    lda #17
    jsr $ffee
    lda #3
    jsr $ffee
    rts

print_high_score_character:  ; A=ASCII code

    clc
    sta $72         ; store the character
    lda $8f
    adc #3
    sta $70         ; store the x position of the character
    lda #30
    sta $71
    ; Run on into the next routine.

print_xy:

    lda #31
    jsr $ffee
    lda $70
    jsr $ffee
    lda $71
    jsr $ffee
    lda $72
    jsr $ffee
    rts

disable_sound:  ; X=1 (disable); X=0 (enable)

    lda #210
    ldy #0
    jmp $fff4   ; optimise away the rts

status_vdu_bytes: .byte 31,2,0, 17,3, "Score", 31,11,0, 17,2, "Strength", 17,1
; TAB(1,0), COLOUR 3, "Score", TAB(12,0), COLOUR 2, "Strength", COLOUR 1

start_new_game:

    ; Clear the screen.
    jsr cls

    ; Set the level.
    lda #0
    sta $578a

    ; Set the score.
    lda #0
    sta $5786
    lda #0
    sta $5787
    lda #0
    sta $5788

    ; Blank the screen now because it will be blanked before the room is shown
    ; and otherwise the strength bar will show briefly.
    jsr blank_screen

    ; Set the player's strength.
    lda #0
    sta $5784
    lda #64
    sta $70
    jsr add_strength

    ; Set the projectile type.
    lda #0
    sta $5789

    rts

reset_player_position:

    lda #1      ; player
    sta $5280
    lda #6      ; down (first frame)
    sta $5281
    lda #4      ; y=4
    sta $5282
    lda #2      ; dy=2
    sta $5283
    lda #4      ; x=4
    sta $5284
    lda #3      ; dx=3
    sta $5285

    rts

start_level:

    ; Clear the item/player flags.
    lda #0
    sta $5780

    ; Set current room.

    ldx $578a
    lda start_rooms_y,x
    sta $5782
    lda start_rooms_x,x
    sta $5783

    ; Set the player's position.

    jsr reset_player_position

    ; Reset the weapon counter.
    lda #0
    sta $577f

    ; Fill the treasure table with objects.
    ldx $578a   ; level
    lda key_rooms,x
    sta $80
    
    ldx $578a   ; level
    lda seeds,x
    adc #1
    and #31
    sta $7c
    clc
    lda seeds,x
    adc #2
    and #31
    sta $7d
    clc

    lda $578a   ; create an upper limit on the weapon type found in this level
    adc #2
    sta $5781
    clc

    lda #$00
    sta $8e
    lda #$52
    sta $8f

    ldy #0
    start_level_add_treasure_loop:

        cpy $80                         ; check for the key room
        bne start_level_add_treasure_item

        lda #5                          ; the value to store is type + 1
        jmp start_level_add_treasure_store

        start_level_add_treasure_item:
        clc
        jsr unlimited_values
        and #$0f
        cmp #0
        beq start_level_add_treasure_none

        clc
        sta $8c
        tya
        adc $8c
        and #31
        clc
        tax
        lda treasure_table,x

        cmp #4
        bmi start_level_add_treasure_weapon

        clc
        adc #1
        jmp start_level_add_treasure_store

        start_level_add_treasure_weapon:

        ; Only add weapons with types that equal the level number or exceed it
        ; by one.
        cmp $5781                     
        bcs start_level_add_treasure_none

        clc
        adc #1                              ; store values 0-8 as values 1-9
        jmp start_level_add_treasure_store

        start_level_add_treasure_none:
        clc
        lda #0                  ; do not put treasure in this room

        start_level_add_treasure_store:
        clc
        sta ($8e),y             ; add the item to the table

        iny
        cpy #121
        bmi start_level_add_treasure_loop

    ; Write the status text.
    ldx #0
    write_status_text_loop:
        lda status_vdu_bytes,x
        jsr $ffee
        inx
        cpx #25
        bmi write_status_text_loop

    jsr write_score

    clc
    rts

main:
    jsr init

    main_loop:

        jsr show_title

        jsr start_new_game

        level_loop:

            jsr start_level

            game_loop:

                jsr remove_characters

                jsr reset_unplot_buffer
                jsr reset_plot_buffer

                lda $5782       ; current room (y)
                sta $78
                lda $5783       ; current room (x)
                sta $79
                jsr plot_room
                jsr set_room_palette
                jsr create_enemy_positions
                jsr add_treasure

                jsr plot_the_player

                lda #0          ; reset projectile counter
                sta $578d

                lda #0          ; reset motion counter
                sta $578e

                lda #63         ; reset generation counter
                sta $578f

                room_loop:
                    jsr reset_unplot_buffer
                    jsr reset_plot_buffer

                    jsr move_characters
                    jsr move_projectile

                    lda $5780   ; is player out of strength ($40), leaving the
                    and #$c2    ; level (0x80) or completing the game (0x02)?
                    beq room_loop_player_move
                    clc

                    dec $5785           ; leave the loop when the delay
                    bne room_loop_delay_next
                    jmp after_room_loop ; counter is about to reset

                    room_loop_delay_next:

                    lda $5281           ; leave the loop when the player demise
                    cmp #11             ; animation has finished
                    beq room_loop_after_player_move
                    clc

                    lda $578e
                    and #7
                    bne room_loop_after_player_move

                    lda $5780   ; skip the animation if leaving the level or
                    and #$82    ; completing the game
                    bne room_loop_after_player_move

                    ; Show the demise animation when appropriate.

                    lda #$80
                    sta $74
                    lda #$52
                    sta $75

                    jsr unplot_character

                    inc $5281
                    jsr plot_character
                    jmp room_loop_after_player_move

                    room_loop_player_move:

                    ; See if it is time to generate a new enemy.
                    lda $578f
                    cmp #0
                    bne no_emerge_characters
                    jsr emerge_characters

                    no_emerge_characters:
                    clc

                    jsr check_fire_key
                    jsr move_player
                    bcs after_room_loop     ; check if we are leaving the level

                    room_loop_after_player_move:
                    clc

                    lda #19
                    jsr $fff4
                    jsr plot_buffer

                    ldx #143            ; Escape key check
                    jsr check_key
                    cpy #255
                    beq main_loop_play_again

                    ldx #174            ; S key check
                    jsr check_key
                    cpy #255
                    bne no_set_sound

                    ldx #0
                    jsr disable_sound
                    jmp after_sound_checks

                    no_set_sound:

                    ldx #239            ; Q key check
                    jsr check_key
                    cpy #255
                    bne after_sound_checks

                    ldx #1
                    jsr disable_sound

                    after_sound_checks:

                    ldx #200            ; P key check
                    jsr check_key
                    cpy #255
                    bne no_pause

                    pause_loop:

                        ldx #201         ; O key check
                        jsr check_key
                        cpy #255
                        bne pause_loop

                    no_pause:
                    clc

                    lda $578d
                    cmp #0
                    beq room_loop_no_update_projectile_counter

                    dec $578d

                    room_loop_no_update_projectile_counter:

                    dec $578f   ; update generation counter

                    inc $578e   ; update motion counter
                    clc
                    jmp room_loop

                after_room_loop:
                clc

                lda $5780
                and #$80
                bne exit_level

                lda $5780
                and #$40
                bne game_over

                lda $5780
                and #$02
                bne complete_game

                jmp game_loop

            exit_level:

            jsr show_end_of_level_screen

            inc $578a
            clc
            jmp level_loop

            game_over:
            jsr show_game_over
            jmp main_loop_play_again

            complete_game:
            jsr show_end_of_level_screen
            jsr show_complete_game
            jmp main_loop_play_again

        main_loop_play_again:
        jsr cls

        ; Check the score against the high scores.
        jsr check_high_scores

        jmp main_loop

    exit:
    clc
    rts
