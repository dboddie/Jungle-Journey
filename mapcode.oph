; Copyright (C) 2011 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $1900
unlimited_values:   ; $7c,$7d=first,second
                    ; Add $7c and $7d, store the result in $7d and the original
                    ; $7d value in $7c, returning the sum in the accumulator.
    lda $7c
    sta $7b
    lda $7d
    sta $7c
    adc $7b
    sta $7d
    clc
    rts

div9:               ; A = value
    divide_loop:
        cmp #9
        bcc after_divide_loop   ; bmi should work here, I think, but it doesn't
        sec
        sbc #9
        jmp divide_loop

after_divide_loop:
    clc
    rts             ; A % 9

tile_values_map: .byte 0,1,0,0,0,0,2,3

next_value:         ; no argument
    jsr unlimited_values
    lda $7d
    jsr div9
    and #7          ; (next value % 9) & 7
    tax
    lda tile_values_map,x
    sta $7b
    rts

; Room filling routines, writing to 0x579c to 0x57ff.

draw_top_line:
    ldx #9
    lda #2

    draw_top_line_loop0:
        sta $579c,x
        dex
        bpl draw_top_line_loop0

    ldx #3                      ; draw the exit or wall
    lda $76
    draw_top_line_loop1:
        sta $579f,x
        dex
        bpl draw_top_line_loop1
    clc
    rts

draw_left_line:
    ldx #90
    draw_left_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop0

    ldx #30
    draw_left_line_loop1:
        lda $77
        sta $57ba,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop1
    clc
    rts

draw_bottom_line:
    ldx #9
    lda #2
    draw_bottom_line_loop0:
        sta $57f6,x
        dex
        bpl draw_bottom_line_loop0

    ldx #3
    lda $76
    draw_bottom_line_loop1:
        sta $57f9,x
        dex
        bpl draw_bottom_line_loop1
    clc
    rts

draw_right_line:
    ldx #99
    draw_right_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop0

    ldx #30
    draw_right_line_loop1:
        lda $77
        sta $57c3,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop1
    clc
    rts

make_room:          ; $78,$79=i,j

    ; Fill the room with empty space.

    ldx #100
    make_empty_room_loop:
        lda #0
        sta $579c,x
        dex
        bpl make_empty_room_loop

    ; Determine if there is a top exit.

    lda #0
    sta $76

    lda $78         ; i == 0
    cmp #0
    bne not_top_screen
    lda #2
    sta $76
    jmp do_top_exit
not_top_screen:
    clc

    lda $78
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_top_exit
    clc

    lda $78
    eor $79         ; i ^ j
    adc $78         ; + i
    clc
    cmp $79         ; (i ^ j) + i == j
    bne do_top_exit
    lda #2
    sta $76         ; top exit

do_top_exit:
    jsr draw_top_line

; Determine if there is a left exit.
    lda #0
    sta $77

    lda $79
    cmp #0
    bne not_left_screen
    lda #2
    sta $77
    jmp do_left_exit
not_left_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    and #3          ; j & 3
    cmp $70
    beq do_left_exit
    clc

    lda $78
    ora $79         ; i | j
    eor $79         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_left_exit
    lda #2
    sta $77         ; left exit

do_left_exit:
    jsr draw_left_line

; Determine if there is a right exit.
    lda #0
    sta $77

    lda $79
    cmp #10
    bne not_right_screen
    lda #2
    sta $77
    jmp do_right_exit
not_right_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    adc #1
    and #3          ; j & 3
    cmp $70
    beq do_right_exit
    clc

    lda $79
    adc #1
    sta $70

    lda $78
    ora $70         ; i | j
    eor $70         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_right_exit
    lda #2
    sta $77         ; right exit

do_right_exit:
    jsr draw_right_line

; Determine if there is a bottom exit.
    lda #0
    sta $76

    lda $78
    cmp #10
    bne not_bottom_screen
    lda #2
    sta $76
    jmp do_bottom_exit
not_bottom_screen:
    clc

    lda $78
    adc #1
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_bottom_exit
    clc

    lda $78
    adc #1
    sta $70

    eor $79         ; i ^ j
    adc $70         ; + i
    cmp $79         ; (i ^ j) + i == j
    bne do_bottom_exit
    lda #2
    sta $76         ; bottom exit

do_bottom_exit:
    jsr draw_bottom_line

    ; Make sure that the starting room is empty.

    lda $78
    cmp $33f0
    bne not_starting_room
    lda $79
    cmp $33f1
    bne not_starting_room

    rts

    not_starting_room:
    clc

    ; Fill in the room details.

    lda $7f
    adc $79
    sta $7c
    sec
    lda #100
    sbc $78
    sec
    sbc $7e
    sta $7d
    clc

    ; Discard the first ten values.

    ldy #10
    make_room_loop0:
        jsr unlimited_values
        dey
        bne make_room_loop0
    
    ; Fill the room array with values.

    lda #$a7
    sta $70
    lda #$57
    sta $71

    ldy #0
    make_room_loop1:

        jsr next_value
        sta ($70),y
        iny
        cpy #8
        bne make_room_loop1     ; continue the same row

        lda $70
        cmp #$ed
        beq make_room_loop1_exit    ; exit after the last row

        adc #10
        sta $70
        ldy #0                  ; reset the row counter
        jmp make_room_loop1
    
    make_room_loop1_exit:
    rts


plot:               ; $70,$71=source address
                    ; $72,$73=destination address
    ldy #$1f
    plotloop0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    plotloop1:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$20
        bpl plotloop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    plotloop2:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$40
        bpl plotloop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts

plot_blank:         ; $72,$73=destination address

    ldy #$1f
    lda #0
    plot_blank_loop0:
        sta ($72),y
        dey
        bpl plot_blank_loop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    lda #0
    plot_blank_loop1:
        sta ($72),y
        dey
        cpy #$20
        bpl plot_blank_loop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    lda #0
    plot_blank_loop2:
        sta ($72),y
        dey
        cpy #$40
        bpl plot_blank_loop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts

plot_tile:          ; $7b=tile number
                    ; $72,$73=screen position 

    lda $7b
    cmp #1
    bne not_flowers
    lda #$00
    sta $70
    lda #$53
    sta $71
    jmp plot_not_blank

not_flowers:
    cmp #2
    bne not_tree1
    lda #$60
    sta $70
    lda #$53
    sta $71
    jmp plot_not_blank

not_tree1:
    cmp #3
    bne not_tree2
    lda #$c0
    sta $70
    lda #$53
    sta $71
    jmp plot_not_blank

not_tree2:
    clc
    jmp plot_blank      ; optimise away the rts

plot_not_blank:
    clc
    lda $33fa
    and #3
    tax
    plot_add_loop:
        cpx #0
        beq after_plot_add_loop
        clc
        lda $70
        adc #$20
        sta $70
        lda $71
        adc #$01
        sta $71
        dex
        jmp plot_add_loop

after_plot_add_loop:
    clc
    jsr plot
    rts

plot_room:          ; $78,$79 = i,j (from $33f0,$33f1)
    jsr blank_screen

    lda $33f2
    sta $78
    lda $33f3
    sta $79

    lda #$80
    sta $72
    lda #$5a
    sta $73         ; $72,$73 = screen position

    jsr make_room

    lda #0
    sta $7a
    row_loop:

        lda #9
        sta $76

        column_loop:
            lda $7a
            tax
            lda $579c,x
            sta $7b
            jsr plot_tile

            lda $7a
            adc #1
            sta $7a
            lda $76
            sec
            sbc #1
            sta $76
            clc
            cmp #0
            bpl column_loop

        clc

        lda $72
        adc #$80
        sta $72
        lda $73
        adc #$02
        sta $73
        clc
        cmp #$80
        beq end_rows

        jmp row_loop
    
end_rows:
    lda #1
    sta $70
    lda $78
    eor $79
    and #3
    asl
    adc #1
    sta $71
    jsr set_palette

    lda #2
    sta $70
    sta $71
    jsr set_palette
    lda #3
    sta $70
    sta $71
    jsr set_palette
    rts



plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop8x24_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop8x24_y0_0
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #31

    plotloop8x24_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #16
        bpl plotloop8x24_y0_1
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #47

    plotloop8x24_y0_2:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop8x24_y0_2

    rts

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c
;
; Write to screen in this arrangement:
; -- --
; 00 08
;
; 04 0c
; 10 18
;
; 14 1c
; 20 28
;
; 24 2c

plot8x24_y1:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2              ; plotting 3 8x8 pieces

    plotloop8x24_y1_loop:

        ldy #3

        plotloop8x24_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y1_0
        clc

        ldy #11

        plotloop8x24_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x24_y1_1
        clc

        lda $70
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldy #3

        plotloop8x24_y1_2:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y1_2
        clc

        ldy #11

        plotloop8x24_y1_3:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x24_y1_3
        clc

        lda $70
        adc #12
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        dex
        bpl plotloop8x24_y1_loop

    rts

plot16x16_y0:           ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #31

    plotloop16x16_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop16x16_y0_0
    clc

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 32
    clc

    ldy #63

    plotloop16x16_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop16x16_y0_1
    clc

    rts

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c 30 34 38 3c
;
; Write to screen in this arrangement:
; -- -- -- --
; 00 08 10 18
;
; 04 0c 14 1c
; 20 28 30 38
;
; 24 2c 34 3c

plot16x16_y1:           ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #3

    plotloop16x16_y1_loop:

        ldy #3

        plotloop16x16_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop16x16_y1_0
        clc

        ldy #11

        plotloop16x16_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop16x16_y1_1
        clc

        ldy #19

        plotloop16x16_y1_2:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #16
            bpl plotloop16x16_y1_2
        clc

        ldy #27

        plotloop16x16_y1_3:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #24
            bpl plotloop16x16_y1_3
        clc

        dex
        bmi plotloop16x16_y1_exit
        txa
        and #1
        bne plotloop16x16_y1_loop_next

        lda $70         ; add by 4 to start the next half row
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; add 0x140 - 4 to plot the next top half row
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        jmp plotloop16x16_y1_loop

        plotloop16x16_y1_loop_next:
        clc

        lda $70         ; add 28 to start the next row
        adc #$1c
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; add 4 to plot the next half row
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        jmp plotloop16x16_y1_loop

    plotloop16x16_y1_exit:
    clc
    rts

plot8x8_y0:             ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #31

    plotloop8x8_y0_0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop8x8_y0_0
    clc

    rts

; Sprite data stored in memory: 00 04
;
; Write to screen in this arrangement:
; --
; 00
;
; 04

plot8x8_y1:             ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #1

    plotloop8x8_y1_loop:

        ldy #3

        plotloop8x8_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x8_y1_0
        clc

        ldy #11

        plotloop8x8_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x8_y1_1
        clc

        dex
        bmi plot8x8_y1_exit
        clc

        lda $70         ; add by 4 to start the next half row
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; subtract by 0x140 - 4 to plot the next top half row
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        jmp plotloop8x8_y1_loop

    plot8x8_y1_exit:
    clc

    rts


check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

key_input:              ; returns A=0 (no key), 1 (left), 2 (right), 3 (up)
                        ;           4 (down), 5 (fire)

    ldx #158            ; -98 (Z)
    jsr check_key
    cpy #255
    bne not_left_key
    lda #1
    rts

not_left_key:
    ldx #189            ; -67 (X)
    jsr check_key
    cpy #255
    bne not_right_key
    lda #2
    rts

not_right_key:
    ldx #183            ; -73 (:)
    jsr check_key
    cpy #255
    bne not_up_key
    lda #3
    rts

not_up_key:
    ldx #151            ; -105 (/)
    jsr check_key
    cpy #255
    bne not_down_key
    lda #4
    rts

not_down_key:
    ldx #182            ; -74 (Return)
    jsr check_key
    cpy #255
    bne not_fire_key
    lda #5
    rts

not_fire_key:
    lda #0
    rts

player_direction_chars_low: .byte $00,$30,$60,$90,$c0,$f0,$20,$50
player_direction_chars_high: .byte $34,$34,$34,$34,$34,$34,$35,$35

screen_rows_low: .byte $80,$40,$00,$c0,$80,$40,$00,$c0,$80,$40
screen_rows_high: .byte $5a,$5e,$62,$65,$69,$6d,$71,$74,$78,$7c
screen_subrows_low: .byte $00,$04,$40,$44,$80,$84
screen_subrows_high: .byte $00,$00,$01,$01,$02,$02

screen_columns_low: .byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00,$20
screen_columns_high: .byte $00,$00,$00,$00,$00,$00,$00,$00,$01,$01
screen_subcolumns_low: .byte $00,$08,$10,$18

enemy_direction_chars_low: .byte $c0,$00,$40,$80,$c0,$00,$40,$80
enemy_direction_chars_high: .byte $36,$37,$37,$37,$37,$38,$38,$38

plot_characters:

    lda #$00
    sta $74
    lda #$33
    sta $75

    plot_characters_loop:

        ldy #0
        lda ($74),y
        cmp #0
        bne plot_characters_read_character
        jmp plot_characters_next

        plot_characters_read_character:
        clc

        sta $77         ; temporarily store the object type

        ; Use lookup tables to load the offsets into the sprite.

        ; Direction
        iny
        lda ($74),y
        sta $80         ; temporarily store the direction

        ; y
        iny
        lda ($74),y
        tax
        lda screen_rows_low,x
        sta $72
        lda screen_rows_high,x
        sta $73
        clc

        ; dy
        iny
        lda ($74),y
        sta $76
        tax
        lda screen_subrows_low,x
        adc $72
        sta $72
        lda screen_subrows_high,x
        adc $73
        sta $73
        clc

        ; x
        iny
        lda ($74),y
        tax
        lda screen_columns_low,x
        adc $72
        sta $72
        lda screen_columns_high,x
        adc $73
        sta $73
        clc

        ; dx
        iny
        lda ($74),y
        tax
        lda screen_subcolumns_low,x
        adc $72
        sta $72
        clc

        lda $77
        cmp #1
        bne plot_characters_loop_not_player
        
        ; Plot 8x24 sprites (player)

        ldx $80
        lda player_direction_chars_low,x
        sta $70
        lda player_direction_chars_high,x
        sta $71

        ; Use the dy value to determine which plotting routine to use.

        lda $76
        and #1
        bne plot_characters_plot_8x24_1

        jsr plot8x24_y0
        jmp plot_characters_next

        plot_characters_plot_8x24_1:
        clc
        jsr plot8x24_y1
        jmp plot_characters_next


        plot_characters_loop_not_player:
        cmp #2
        bne plot_characters_loop_not_projectile

        ; Plot 8x8 sprites (projectiles)

        ; Use the dy value to determine which plotting routine to use.

        lda $76
        and #1
        bne plot_characters_plot_8x8_1

        jsr plot8x8_y0
        jmp plot_characters_next

        plot_characters_plot_8x8_1:
        clc
        jsr plot8x8_y1
        jmp plot_characters_next


        plot_characters_loop_not_projectile:
        cmp #3
        bne plot_characters_loop_not_explosion

        ; Plot 16x16 sprites (explosions)


        plot_characters_loop_not_explosion:
        cmp #4
        bmi plot_characters_loop_not_enemy

        ; Plot 16x16 sprites (enemies)

        ; Select the set of sprites to use.

        and #248
        lsr
        lsr     ; bits 3,4,5 >> 2
        clc
        sta $71 ; 0x00, 0x02, 0x04, 0x06, 0x08

        ldx $80
        lda enemy_direction_chars_low,x
        sta $70
        lda enemy_direction_chars_high,x
        adc $71
        sta $71

        ; Use the dy value to determine which plotting routine to use.

        lda $76
        and #1
        bne plot_characters_plot_16x16_1

        jsr plot16x16_y0
        jmp plot_characters_next

        plot_characters_plot_16x16_1:
        clc
        jsr plot16x16_y1
        jmp plot_characters_next


        plot_characters_loop_not_enemy:
        clc

        plot_characters_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$3c
        bpl plot_characters_exit
        sta $74
        jmp plot_characters_loop

    plot_characters_exit:
    clc
    rts

; Note that the room offsets reflect that the room is 
room_row_offsets_low: .byte $9c,$a6,$b0,$ba,$c4,$ce,$d8,$e2,$ec,$f6

animate_player_left:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1
    eor #1      ; toggle animation flag
    sta $3301   ; left (directional bits are 0)
    rts

animate_player_right:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #2      ; right
    sta $3301
    rts

animate_player_up:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #4      ; up
    sta $3301
    rts

animate_player_down:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #6      ; down
    sta $3301
    rts

move_player:

    ; Handle the left key.

    ldx #158            ; (Z)
    jsr check_key
    cpy #255
    bne move_player_not_left_key

    lda $3305           ; read dx
    cmp #0
    beq move_player_left_check_x

    dec $3305
    clc
    jmp animate_player_left ; optimise away the rts
    
    move_player_left_check_x:   ; Check the x offset.

    lda $3304
    cmp #0
    beq move_player_leave_room_left

    sec
    sbc #1                      ; x - 1
    tay
    lda $3302                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y             ; load the tile to the left

    cmp #0
    bne move_player_not_left_key

    lda $3303               ; dy
    cmp #0
    beq move_player_allow_left

    clc
    lda $70                 ; dy > 0 so we need to check another tile
    adc #10
    sta $70
    lda ($70),y             ; load the tile below and to the left

    cmp #0
    bne move_player_not_left_key

    move_player_allow_left:
    tya
    sta $3304               ; store the new room x offset
    lda #3
    sta $3305               ; dx = 3
    clc
    jmp animate_player_left ; optimise away the rts

    move_player_leave_room_left:
    sec
    lda $33f3
    sbc #1
    sta $33f3
    clc

    ; Set the player's position on the right of the screen.

    lda #9      ; x = 9
    sta $3304
    lda #2      ; dx = 2
    sta $3305

    sec                     ; indicate to the calling routine that the player
    jmp animate_player_left ; has left the room (optimising away the rts)

    move_player_not_left_key:

    ; Handle the right key.

    ldx #189            ; (X)
    jsr check_key
    cpy #255
    bne move_player_not_right_key

    lda $3305                   ; read dx
    cmp #2
    bpl move_player_right_check_x

    inc $3305
    clc
    jmp animate_player_right    ; optimise away the rts
    
    move_player_right_check_x:  ; Check the x offset.

    lda $3304
    cmp #9
    beq move_player_leave_room_right

    clc
    adc #1                      ; x + 1
    tay
    lda $3302                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_player_not_right_key

    lda $3303                   ; dy
    cmp #0
    beq move_player_allow_right

    clc                         ; dy > 0 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_player_not_right_key

    move_player_allow_right:

    lda $3305                   ; only if the player is leaving the tile
    cmp #3                      ; do we update the x offset
    beq move_player_right_tile

    inc $3305                   ; otherwise, we update dx instead
    clc
    jmp animate_player_right    ; optimise away the rts

    move_player_right_tile:

    tya
    sta $3304               ; store the new room x offset
    lda #0
    sta $3305               ; dx = 0
    clc
    jmp animate_player_right ; optimise away the rts

    move_player_leave_room_right:
    clc
    lda $33f3
    adc #1
    sta $33f3
    clc

    ; Set the player's position on the left of the screen.

    lda #0      ; x = 0
    sta $3304
    lda #0      ; dx = 0
    sta $3305

    sec                         ; indicate to the calling routine that the
    jmp animate_player_right    ; player has left the room (optimising away the
                                ; rts)

    move_player_not_right_key:

    ; Handle the up key.

    ldx #183            ; (:)
    jsr check_key
    cpy #255
    bne move_player_not_up_key

    lda $3303           ; read dy
    cmp #0
    beq move_player_up_check_y

    dec $3303
    clc
    jmp animate_player_up       ; optimise away the rts
    
    move_player_up_check_y:     ; Check the y offset.

    lda $3302
    cmp #0
    beq move_player_leave_room_up

    sec
    sbc #1                      ; y - 1
    tax                         ; use the y offset as an index
    lda $3304                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_player_not_up_key

    lda $3305                   ; dx
    cmp #3
    bmi move_player_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_player_not_up_key

    move_player_allow_up:
    txa
    sta $3302               ; store the new room y offset
    lda #5
    sta $3303               ; dy = 5
    clc
    jmp animate_player_up   ; optimise away the rts

    move_player_leave_room_up:
    sec
    lda $33f2
    sbc #1
    sta $33f2
    clc

    ; Set the player's position on the bottom of the screen.

    lda #9      ; y = 9
    sta $3302
    lda #0      ; dy = 0
    sta $3303

    sec                     ; indicate to the calling routine that the player
    jmp animate_player_up   ; has left the room (optimising away the rts)

    move_player_not_up_key:

    ; Handle the down key.

    ldx #151            ; (/)
    jsr check_key
    cpy #255
    bne move_player_not_down_key

    lda $3303                   ; read dy
    cmp #0
    beq move_player_down_check_y
    cmp #5
    beq move_player_down_check_y

    inc $3303                   ; 0 < dy < 5
    clc
    jmp animate_player_down    ; optimise away the rts
    
    move_player_down_check_y:  ; Check the y offset.

    lda $3302
    cmp #9
    beq move_player_leave_room_down

    clc
    adc #1                      ; y + 1
    tax
    lda $3304                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_player_not_down_key

    lda $3305                   ; dx
    cmp #3
    bmi move_player_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_player_not_down_key

    move_player_allow_down:

    lda $3303                   ; only if the player is leaving the tile
    cmp #5                      ; do we update the y offset
    beq move_player_down_tile

    inc $3303                   ; otherwise, we update dy instead
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_down_tile:

    txa
    sta $3302                   ; store the new room y offset
    lda #0
    sta $3303                   ; dy = 0
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_leave_room_down:
    clc
    lda $33f2
    adc #1
    sta $33f2
    clc

    ; Set the player's position on the top of the screen.

    lda #0      ; y = 0
    sta $3302
    lda #0      ; dy = 0
    sta $3303

    sec                         ; indicate to the calling routine that the
    jmp animate_player_down     ; player has left the room (optimising away the
                                ; rts)

    move_player_not_down_key:
    clc
    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $33fb
    lda $71
    sta $33fc
    lda #0
    sta $33fd
    sta $33fe
    sta $33ff

    lda #$c         
    ldx #$fb
    ldy #$33
    jsr $fff1
    rts

blank_screen:
    lda #1
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #2
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #3
    sta $70
    lda #0
    sta $71
    jsr set_palette
    rts

sprites_file_name: .byte "SPRITES", 13
chars_file_name: .byte "CHARS", 13

sprites_block: .byte <sprites_file_name, >sprites_file_name
               .byte 0, $53, 0, 0
               .byte 0, $53, 0, 0
               .byte $60, $03, 0, 0
               .byte $60, $56, 0, 0

chars_block: .byte <chars_file_name, >chars_file_name
               .byte $00, $34, 0, 0
               .byte $00, $34, 0, 0
               .byte $c0, $11, 0, 0
               .byte $c0, $45, 0, 0

init:
    lda #255
    ldx #<sprites_block
    ldy #>sprites_block
    jsr $ffdd

    lda #255
    ldx #<chars_block
    ldy #>chars_block
    jsr $ffdd

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

start_new_game:

    ; Set level.

    lda #0
    sta $33fa

    ; Set starting room and current room.

    lda #5
    sta $33f0
    sta $33f2
    lda #5
    sta $33f1
    sta $33f3

    ; Clear the character table and set player position.

    ldx #0
    clear_character_loop:
        lda #0
        sta $3300,x
        txa
        adc #6
        tax
        cpx #$f0
        bmi clear_character_loop

    lda #1      ; player
    sta $3300
    lda #6      ; down (first frame)
    sta $3301
    lda #5      ; y=5
    sta $3302
    lda #0      ; dy=0
    sta $3303
    lda #5      ; x=5
    sta $3304
    lda #0      ; dx=0
    sta $3305

;    lda #$4     ; enemy (0)
;    sta $330c
;    lda #0      ; left up (first frame)
;    sta $330d
;    lda #3      ; y=3
;    sta $330e
;    lda #1      ; dy=1
;    sta $330f
;    lda #3      ; x=3
;    sta $3310
;    lda #0      ; dx=0
;    sta $3311
;
;    lda #$c     ; enemy (1)
;    sta $3312
;    lda #4      ; left down (first frame)
;    sta $3313
;    lda #3      ; y=3
;    sta $3314
;    lda #0      ; dy=0
;    sta $3315
;    lda #7      ; x=7
;    sta $3316
;    lda #0      ; dx=0
;    sta $3317
;
;    lda #$14    ; enemy (2)
;    sta $3318
;    lda #2      ; right up (first frame)
;    sta $3319
;    lda #7      ; y=7
;    sta $331a
;    lda #0      ; dy=0
;    sta $331b
;    lda #3      ; x=3
;    sta $331c
;    lda #0      ; dx=0
;    sta $331d
;
;    lda #$1c    ; enemy (3)
;    sta $331e
;    lda #2      ; right up (first frame)
;    sta $331f
;    lda #7      ; y=7
;    sta $3320
;    lda #0      ; dy=0
;    sta $3321
;    lda #3      ; x=3
;    sta $3322
;    lda #0      ; dx=0
;    sta $3323
;
;    lda #$24    ; enemy (4)
;    sta $3324
;    lda #6      ; right down (first frame)
;    sta $3325
;    lda #7      ; y=7
;    sta $3326
;    lda #0      ; dy=0
;    sta $3327
;    lda #7      ; x=7
;    sta $3328
;    lda #0      ; dx=0
;    sta $3329
    rts

main:
    jsr init

    main_loop:

        main_wait_loop:
            lda #129
            ldx #157
            ldy #255
            jsr $fff4
            cpy #255
            bne main_wait_loop

        jsr start_new_game

        game_loop:
            lda $33f2
            sta $78
            lda $33f3
            sta $79
            jsr plot_room
            jsr plot_characters

            room_loop:
                lda #19
                jsr $fff4
                jsr plot_characters ; unplot
                jsr move_player
                bcs after_room_loop

                jsr plot_characters ; plot
                ldx #157
                jsr check_key
                cpy #255
                beq exit
                clc
                jmp room_loop

        after_room_loop:
            clc
            jmp game_loop

        jmp main_loop

    exit:
    clc
    rts
