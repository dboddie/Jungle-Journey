.org $1900
unlimited_values:   ; $7c,$7d=first,second
                    ; Add $7c and $7d, store the result in $7d and the original
                    ; $7d value in $7c, returning the sum in the accumulator.
    lda $7c
    sta $7b
    lda $7d
    sta $7c
    adc $7b
    sta $7d
    clc
    rts

div9:               ; A = value
    divide_loop:
        cmp #9
        bcc after_divide_loop   ; bmi should work here, I think, but it doesn't
        sec
        sbc #9
        jmp divide_loop

after_divide_loop:
    clc
    rts             ; A % 9

next_value:         ; no argument
    jsr unlimited_values
    lda $7d
    jsr div9
    and #7
    sta $7b
    rts             ; $7b = (next value % 9) & 3

; Room filling routines, writing to 0x579c to 0x57ff.

draw_top_line:
    ldx #9
    lda #6

    draw_top_line_loop0:
        sta $57f6,x
        dex
        bpl draw_top_line_loop0

    ldx #3
    lda $76
    draw_top_line_loop1:
        sta $57f9,x
        dex
        bpl draw_top_line_loop1
    clc
    rts

draw_left_line:
    ldx #99
    draw_left_line_loop0:
        lda #6
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop0

    ldx #39
    draw_left_line_loop1:
        lda $77
        sta $57ba,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop1
    clc
    rts

draw_bottom_line:
    ldx #9
    lda #6
    draw_bottom_line_loop0:
        sta $579c,x
        dex
        bpl draw_bottom_line_loop0

    ldx #3
    lda $76
    draw_bottom_line_loop1:
        sta $579f,x
        dex
        bpl draw_bottom_line_loop1
    clc
    rts

draw_right_line:
    ldx #90
    draw_right_line_loop0:
        lda #6
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop0

    ldx #30
    draw_right_line_loop1:
        lda $77
        sta $57ba,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop1
    clc
    rts

make_room:          ; $78,$79=i,j

; Determine if there is a top exit.
    lda #0
    sta $76

    lda $78         ; i == 0
    cmp #0
    bne not_top_screen
    lda #6
    sta $76
    jmp do_top_exit
not_top_screen:
    clc

    lda $78
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_top_exit
    clc

    lda $78
    eor $79         ; i ^ j
    adc $78         ; + i
    clc
    cmp $79         ; (i ^ j) + i == j
    bne do_top_exit
    lda #6
    sta $76         ; top exit

do_top_exit:
    jsr draw_top_line

; Determine if there is a left exit.
    lda #0
    sta $77

    lda $79
    cmp #0
    bne not_left_screen
    lda #6
    sta $77
    jmp do_left_exit
not_left_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    and #3          ; j & 3
    cmp $70
    beq do_left_exit
    clc

    lda $78
    ora $79         ; i | j
    eor $79         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_left_exit
    lda #6
    sta $77         ; left exit

do_left_exit:
    jsr draw_left_line

; Determine if there is a right exit.
    lda #0
    sta $77

    lda $79
    cmp #10
    bne not_right_screen
    lda #6
    sta $77
    jmp do_right_exit
not_right_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    adc #1
    and #3          ; j & 3
    cmp $70
    beq do_right_exit
    clc

    lda $79
    adc #1
    sta $70

    lda $78
    ora $70         ; i | j
    eor $70         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_right_exit
    lda #6
    sta $77         ; right exit

do_right_exit:
    jsr draw_right_line

; Determine if there is a bottom exit.
    lda #0
    sta $76

    lda $78
    cmp #10
    bne not_bottom_screen
    lda #6
    sta $76
    jmp do_bottom_exit
not_bottom_screen:
    clc

    lda $78
    adc #1
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_bottom_exit
    clc

    lda $78
    adc #1
    sta $70

    eor $79         ; i ^ j
    adc $70         ; + i
    cmp $79         ; (i ^ j) + i == j
    bne do_bottom_exit
    lda #6
    sta $76         ; bottom exit

do_bottom_exit:
    jsr draw_bottom_line

    ; Fill in the room details.

    lda $7f
    adc $79
    sta $7c
    sec
    lda #100
    sbc $78
    sec
    sbc $7e
    sta $7d
    clc
                    ; Discard the first ten values.
    ldy #10
    make_room_loop0:
        jsr unlimited_values
        dey
        bne make_room_loop0
    
                    ; Fill the room array with values.
    ldx #78
    ldy #63
    make_room_loop1:
        jsr next_value
        sta $57a6,x
        dey
        tya
        and #7
        cmp #7
        bne next1
    dex
    dex

next1:
    clc
    dex
    bpl make_room_loop1
    
    rts


plot:               ; $70,$71=source address
                    ; $72,$73=destination address
    ldy #$1f
    plotloop0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    plotloop1:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$20
        bpl plotloop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    plotloop2:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$40
        bpl plotloop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts


plot_tile:          ; $7b=tile number
                    ; $72,$73=screen position 

    lda $7b
    cmp #1
    bne not_flowers
    lda #$60
    sta $70
    lda #$56
    sta $71
    clc
    jmp plot        ; optimise away the rts
not_flowers:
    cmp #6
    bne not_tree1
    lda #$c0
    sta $70
    lda #$56
    sta $71
    clc
    jmp plot        ; optimise away the rts
not_tree1:
    cmp #7
    bne not_tree2
    lda #$20
    sta $70
    lda #$57
    sta $71
    clc
    jmp plot        ; optimise away the rts
not_tree2:
    lda #$00
    sta $70
    lda #$56
    sta $71
    clc
    jsr plot
    rts

plot_room:          ; $78,$79 = i,j (from $4ff0,$4ff1)
    jsr blank_screen

    lda $4ff0
    sta $78
    lda $4ff1
    sta $79

    lda #$00
    sta $72
    lda #$58
    sta $73         ; $72,$73 = screen position

    jsr make_room

    lda #99
    sta $7a
    row_loop:

        lda #9
        sta $76

        column_loop:
            lda $7a
            tax
            lda $579c,x
            sta $7b
            jsr plot_tile

            lda $7a
            sec
            sbc #1
            sta $7a
            lda $76
            sec
            sbc #1
            sta $76
            clc
            cmp #0
            bpl column_loop

        clc

        lda $72
        adc #$80
        sta $72
        lda $73
        adc #$02
        sta $73
        clc
        cmp #$7d
        beq end_rows

        jmp row_loop
    
end_rows:
    lda #1
    sta $70
    lda $78
    eor $79
    and #3
    asl
    adc #1
    sta $71
    jsr set_palette

    lda #2
    sta $70
    sta $71
    jsr set_palette
    lda #3
    sta $70
    sta $71
    jsr set_palette
    rts



plot12x24_y0:           ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop12x24_y0_0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop12x24_y0_0
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #31

    plotloop12x24_y0_1:
        lda ($70),y
        sta ($72),y
        dey
        cpy #16
        bpl plotloop12x24_y0_1
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #47

    plotloop12x24_y0_2:
        lda ($70),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop12x24_y0_2

    rts


; Sprite data stored in memory: 00 11 22 33 44 55 66 77 88 99 aa bb
;
; Write to screen in this arrangement:
; -- --
; 00 22
;
; 11 33
; 44 66
;
; 55 77
; 88 aa
;
; 99 bb

plot12x24_y1:           ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2

    plotloop12x24_y1_loop:

        ldy #3

        plotloop12x24_y1_0:
            lda ($70),y
            sta ($72),y
            dey
            bpl plotloop12x24_y1_0
        clc

        ldy #11

        plotloop12x24_y1_1:
            lda ($70),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop12x24_y1_1
        clc

        lda $70
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldy #3

        plotloop12x24_y1_2:
            lda ($70),y
            sta ($72),y
            dey
            bpl plotloop12x24_y1_2
        clc

        ldy #11

        plotloop12x24_y1_3:
            lda ($70),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop12x24_y1_3
        clc

        lda $70
        adc #12
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        dex
        bpl plotloop12x24_y1_loop

    rts


key_input:
    lda #129
    ldx #158
    ldy #255
    jsr $fff4
    cpy #255
    bne not_left_key
    lda #1
    sta $74
    jmp exit_keys
not_left_key:    
    lda #129
    ldx #151
    ldy #255
    jsr $fff4
    cpy #255
    bne not_down_key
    lda #2
    sta $74
    jmp exit_keys
not_down_key:
    lda #0
    sta $74
exit_keys:
    rts


set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $4ffb
    lda $71
    sta $4ffc
    lda #0
    sta $4ffd
    sta $4ffe
    sta $4fff

    lda #$c         
    ldx #$fb
    ldy #$4f
    jsr $fff1
    rts

blank_screen:
    lda #1
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #2
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #3
    sta $70
    lda #0
    sta $71
    jsr set_palette
    rts

sprites_file_name: .byte "SPRITES", 13
chars_file_name: .byte "CHARS", 13

sprites_block: .byte <sprites_file_name, >sprites_file_name
               .byte 0, $56, 0, 0
               .byte 0, $56, 0, 0
               .byte $80, $01, 0, 0
               .byte $80, $57, 0, 0

init:
    lda #255
    ldx #<sprites_block
    ldy #>sprites_block
    jsr $ffdd

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

start_new_game:
    lda #5
    sta $4ff0
    lda #5
    sta $4ff1

    rts

main:
    jsr init

    main_loop:

        main_wait_loop:
            lda #129
            ldx #157
            ldy #255
            jsr $fff4
            cpy #255
            bne main_wait_loop

        jsr start_new_game
        jsr plot_room

        game_loop:

        jmp main_loop
    rts
