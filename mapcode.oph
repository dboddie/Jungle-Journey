; Copyright (C) 2011 David Boddie <david@boddie.org.uk>
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <http://www.gnu.org/licenses/>.

.org $1900
unlimited_values:   ; $7c,$7d=first,second
                    ; Add $7c and $7d, store the result in $7d and the original
                    ; $7d value in $7c, returning the sum in the accumulator.
    lda $7c
    sta $7b
    lda $7d
    sta $7c
    adc $7b
    sta $7d
    clc
    rts

mod9:               ; A = value
    divide_loop:
        cmp #9
        bcc after_divide_loop   ; bmi should work here, I think, but it doesn't
        sec
        sbc #9
        jmp divide_loop

after_divide_loop:
    clc
    rts             ; A % 9

tile_values_map: .byte 0,1,0,0,0,0,2,3

next_value:         ; no argument
    jsr unlimited_values
    lda $7d
    jsr mod9
    and #7          ; (next value % 9) & 7
    tax
    lda tile_values_map,x
    sta $7b
    rts

; Room filling routines, writing to 0x579c to 0x57ff.

draw_top_line:
    ldx #9
    lda #2

    draw_top_line_loop0:
        sta $579c,x
        dex
        bpl draw_top_line_loop0

    ldx #3                      ; draw the exit or wall
    lda $76
    draw_top_line_loop1:
        sta $579f,x
        dex
        bpl draw_top_line_loop1
    clc
    rts

draw_left_line:
    ldx #90
    draw_left_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop0

    ldx #30
    draw_left_line_loop1:
        lda $77
        sta $57ba,x
        txa
        sec
        sbc #10
        tax
        bpl draw_left_line_loop1
    clc
    rts

draw_bottom_line:
    ldx #9
    lda #2
    draw_bottom_line_loop0:
        sta $57f6,x
        dex
        bpl draw_bottom_line_loop0

    ldx #3
    lda $76
    draw_bottom_line_loop1:
        sta $57f9,x
        dex
        bpl draw_bottom_line_loop1
    clc
    rts

draw_right_line:
    ldx #99
    draw_right_line_loop0:
        lda #2
        sta $579c,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop0

    ldx #30
    draw_right_line_loop1:
        lda $77
        sta $57c3,x
        txa
        sec
        sbc #10
        tax
        bpl draw_right_line_loop1
    clc
    rts

make_room:          ; $78,$79=i,j

    ; Fills the room array at 579c with values.
    ; Tiles 0,1,2,3 are map tiles that will be shown by the plot_tile routine.
    ; Other tiles are plotted separately:
    ;   4 = exit
    ;   5 = final exit
    ;   6 = weapon (bits 3,4 are type)
    ;   7 = treasure (bits 3,4 are type)

    ; Fill the room with empty space.

    ldx #100
    make_empty_room_loop:
        lda #0
        sta $579c,x
        dex
        bpl make_empty_room_loop

    ; Determine if there is a top exit.

    lda #0
    sta $76

    lda $78         ; i == 0
    cmp #0
    bne not_top_screen
    lda #2
    sta $76
    jmp do_top_exit

    not_top_screen:
    clc

    lda $78
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_top_exit
    clc

    lda $78
    eor $79         ; i ^ j
    adc $78         ; + i
    clc
    cmp $79         ; (i ^ j) + i == j
    bne do_top_exit
    lda #2
    sta $76         ; top exit

    do_top_exit:
    jsr draw_top_line

    ; Determine if there is a left exit.
    lda #0
    sta $77

    lda $79
    cmp #0
    bne not_left_screen
    lda #2
    sta $77
    jmp do_left_exit

    not_left_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    and #3          ; j & 3
    cmp $70
    beq do_left_exit
    clc

    lda $78
    ora $79         ; i | j
    eor $79         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_left_exit
    lda #2
    sta $77         ; left exit

    do_left_exit:
    jsr draw_left_line

    ; Determine if there is a right exit.
    lda #0
    sta $77

    lda $79
    cmp #10
    bne not_right_screen
    lda #2
    sta $77
    jmp do_right_exit

    not_right_screen:
    clc

    lda $78
    and #3          ; i & 3
    sta $70         ; temporary result
    lda $79
    adc #1
    and #3          ; j & 3
    cmp $70
    beq do_right_exit
    clc

    lda $79
    adc #1
    sta $70

    lda $78
    ora $70         ; i | j
    eor $70         ; ^ j
    cmp $78         ; (i | j) ^ j == i
    bne do_right_exit
    lda #2
    sta $77         ; right exit

    do_right_exit:
    jsr draw_right_line

    ; Determine if there is a bottom exit.
    lda #0
    sta $76

    lda $78
    cmp #10
    bne not_bottom_screen
    lda #2
    sta $76
    jmp do_bottom_exit

    not_bottom_screen:
    clc

    lda $78
    adc #1
    and #7          ; i & 7
    sta $70         ; temporary result
    lda $79
    and #7          ; j & 7
    cmp $70
    beq do_bottom_exit
    clc

    lda $78
    adc #1
    sta $70

    eor $79         ; i ^ j
    adc $70         ; + i
    cmp $79         ; (i ^ j) + i == j
    bne do_bottom_exit
    lda #2
    sta $76         ; bottom exit

    do_bottom_exit:
    jsr draw_bottom_line

    ; Make sure that the starting, exit, key rooms are empty.

    ldx $33fa               ; level number
    lda start_rooms_y,x
    cmp $78
    bne make_room_not_starting_room
    lda start_rooms_x,x
    cmp $79
    bne make_room_not_starting_room

    rts

    make_room_not_starting_room:

    lda exit_rooms_y,x
    cmp $78
    bne make_room_not_exit_room
    lda exit_rooms_x,x
    cmp $79
    bne make_room_not_exit_room

    ; Add an exit to the room.
    lda $78
    eor $79
    and #15
    tax
    lda exit_room_offsets,x
    tax
    lda #4
    sta $579c,x

    rts

    make_room_not_exit_room:

    lda key_rooms_y,x
    cmp $78
    bne make_room_not_key_room
    lda key_rooms_x,x
    cmp $79
    bne make_room_not_key_room

    rts

    make_room_not_key_room:
    clc

    ; Fill in the room details.

    lda $7f
    adc $79
    sta $7c
    sec
    ldx $33fa
    lda seeds,x
    sbc $78
    sec
    sbc $7e
    sta $7d
    clc

    ; Discard the first ten values.

    ldy #10
    make_room_loop0:
        jsr unlimited_values
        dey
        bne make_room_loop0
    
    ; Fill the room array with values.

    lda #$a7
    sta $70
    lda #$57
    sta $71

    ldy #0
    make_room_loop1:

        jsr next_value
        sta ($70),y
        iny
        cpy #8
        bne make_room_loop1     ; continue the same row

        lda $70
        cmp #$ed
        beq make_room_loop1_exit    ; exit after the last row

        adc #10
        sta $70
        ldy #0                  ; reset the row counter
        jmp make_room_loop1
    
    make_room_loop1_exit:
    rts

exit_room_offsets:  .byte 35,66,63,56,34,44,64,33,36,55,65,53,45,46,54,43
treasure_x:         .byte 3, 2, 4, 8, 2, 5, 4, 1, 3, 8, 6, 5, 7, 1, 7, 6
treasure_y:         .byte 1, 3, 7, 7, 2, 3, 6, 1, 4, 6, 8, 5, 5, 4, 8, 2

eleven_times_table: .byte 0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110

add_treasure:               ; $78,$79 = i,j

    lda $78
    tax
    lda eleven_times_table,x
    adc $79
    tax

    lda $5100,x
    cmp #0
    beq add_treasure_exit

    sec
    sbc #1
    sta $330d           ; store weapon/treasure type
    clc

    lda $78
    eor $79
    and #15
    sta $70

    lda #15
    sta $8c
    ldy #0
    add_treasure_loop:

        clc

        ldx $70
        lda treasure_y,x    ; y
        sta $8d
        tax
        lda room_row_offsets_low,x
        sta $80

        ldx $70
        lda treasure_x,x    ; x
        sta $8e
        adc $80
        sta $80

        lda #$57
        adc #0
        sta $81
        clc

        lda ($80),y         ; tile
        cmp #0
        bne add_treasure_loop_next

        lda #4              ; type (weapon/treasure)
        sta $330c
        lda $8d             ; y
        sta $330e
        lda #1              ; dy
        sta $330f
        lda $8e             ; x
        sta $3310
        lda #0              ; dx
        sta $3311

        lda #$0c
        sta $74
        lda #$33
        sta $75
        jmp plot_character  ; optimise away the rts

        add_treasure_loop_next:
        lda $70
        cmp #0
        bne add_treasure_loop_next2

        lda #15
        sta $70

        add_treasure_loop_next2:
        dec $70
        dec $8c
        bpl add_treasure_loop

    add_treasure_exit:
    clc
    rts

plot:               ; $70,$71=source address
                    ; $72,$73=destination address
    ldy #$1f
    plotloop0:
        lda ($70),y
        sta ($72),y
        dey
        bpl plotloop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    plotloop1:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$20
        bpl plotloop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    plotloop2:
        lda ($70),y
        sta ($72),y
        dey
        cpy #$40
        bpl plotloop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts

plot_blank:         ; $72,$73=destination address

    ldy #$1f
    lda #0
    plot_blank_loop0:
        sta ($72),y
        dey
        bpl plot_blank_loop0

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$3f
    lda #0
    plot_blank_loop1:
        sta ($72),y
        dey
        cpy #$20
        bpl plot_blank_loop1

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73         ; next line minus 0x20
    clc

    ldy #$5f
    lda #0
    plot_blank_loop2:
        sta ($72),y
        dey
        cpy #$40
        bpl plot_blank_loop2
    
    sec
    lda $72
    sbc #$20
    sta $72
    lda $73
    sbc #$02
    sta $73         ; back two lines minus 0x20
    clc
    
    rts

plot_tile:          ; $7b=tile number
                    ;   1 = flowers/decoration
                    ;   2 = trees/wall
                    ;   3 = trees
                    ;   4 = exit
                    ; $72,$73=screen position 

    lda $7b
    cmp #1
    bne plot_tile_not_flowers
    lda #$00
    sta $70
    lda #$53
    sta $71
    jmp plot_not_blank

    plot_tile_not_flowers:
    cmp #2
    bne plot_tile_not_tree1
    lda #$60
    sta $70
    lda #$53
    sta $71
    jmp plot_not_blank

    plot_tile_not_tree1:
    cmp #3
    bne plot_tile_not_tree2
    lda #$c0
    sta $70
    lda #$53
    sta $71
    jmp plot_not_blank

    plot_tile_not_tree2:
    cmp #4
    bne plot_tile_not_exit
    lda #$c0
    sta $70
    lda #$45
    sta $71
    jmp plot_not_blank_after_add_loop   ; don't adjust the tile for later levels

    plot_tile_not_exit:
    clc
    jmp plot_blank      ; optimise away the rts

    plot_not_blank:
    clc
    lda $33fa
    and #3              ; change the tile set for later levels
    tax
    plot_not_blank_add_loop:
        cpx #0
        beq plot_not_blank_after_add_loop
        clc
        lda $70
        adc #$20
        sta $70
        lda $71
        adc #$01
        sta $71
        dex
        jmp plot_not_blank_add_loop

    plot_not_blank_after_add_loop:
    clc
    jsr plot
    rts

plot_room:          ; $78,$79 = i,j (from $33f2,$33f3)
    jsr blank_screen

    lda $33f2
    sta $78
    lda $33f3
    sta $79

    lda #$80
    sta $72
    lda #$5a
    sta $73         ; $72,$73 = screen position

    jsr make_room

    lda #0
    sta $7a
    row_loop:

        lda #9
        sta $76

        column_loop:
            lda $7a
            tax
            lda $579c,x
            sta $7b
            jsr plot_tile

            lda $7a
            adc #1
            sta $7a
            lda $76
            sec
            sbc #1
            sta $76
            clc
            cmp #0
            bpl column_loop

        clc

        lda $72
        adc #$80
        sta $72
        lda $73
        adc #$02
        sta $73
        clc
        cmp #$80
        beq end_rows

        jmp row_loop
    
end_rows:
    lda #1
    sta $70
    lda $78
    eor $79
    and #3
    tax
    lda room_palettes,x
    sta $71
    jsr set_palette

    lda #2
    sta $70
    sta $71
    jsr set_palette
    lda #3
    sta $70
    sta $71
    jsr set_palette
    rts

room_palettes: .byte 1, 6, 5, 7

plot8x24_y0:            ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop8x24_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop8x24_y0_0
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #31

    plotloop8x24_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #16
        bpl plotloop8x24_y0_1
    clc

    lda $72
    adc #$30
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 16
    clc

    ldy #47

    plotloop8x24_y0_2:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop8x24_y0_2

    clc
    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c
;
; Write to screen in this arrangement:
; -- --
; 00 08
;
; 04 0c
; 10 18
;
; 14 1c
; 20 28
;
; 24 2c

plot8x24_y1:            ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #2              ; plotting 3 8x8 pieces

    plotloop8x24_y1_loop:

        ldy #3

        plotloop8x24_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y1_0
        clc

        ldy #11

        plotloop8x24_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x24_y1_1
        clc

        lda $70
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        ldy #3

        plotloop8x24_y1_2:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x24_y1_2
        clc

        ldy #11

        plotloop8x24_y1_3:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x24_y1_3
        clc

        lda $70
        adc #12
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        dex
        bpl plotloop8x24_y1_loop

    clc
    jmp plot_buffer_loop_next

plot16x16_y0:           ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #31

    plotloop16x16_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop16x16_y0_0
    clc

    lda $72
    adc #$20
    sta $72
    lda $73
    adc #$01
    sta $73     ; 0x140 - 32
    clc

    ldy #63

    plotloop16x16_y0_1:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        cpy #32
        bpl plotloop16x16_y0_1
    clc

    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04 08 0c 10 14 18 1c 20 24 28 2c 30 34 38 3c
;
; Write to screen in this arrangement:
; -- -- -- --
; 00 08 10 18
;
; 04 0c 14 1c
; 20 28 30 38
;
; 24 2c 34 3c

plot16x16_y1:           ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #3

    plotloop16x16_y1_loop:

        ldy #3

        plotloop16x16_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop16x16_y1_0
        clc

        ldy #11

        plotloop16x16_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop16x16_y1_1
        clc

        ldy #19

        plotloop16x16_y1_2:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #16
            bpl plotloop16x16_y1_2
        clc

        ldy #27

        plotloop16x16_y1_3:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #24
            bpl plotloop16x16_y1_3
        clc

        dex
        bmi plotloop16x16_y1_exit
        txa
        and #1
        bne plotloop16x16_y1_loop_next

        lda $70         ; add by 4 to start the next half row
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; add 0x140 - 4 to plot the next top half row
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        jmp plotloop16x16_y1_loop

        plotloop16x16_y1_loop_next:
        clc

        lda $70         ; add 28 to start the next row
        adc #$1c
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; add 4 to plot the next half row
        adc #4
        sta $72
        lda $73
        adc #0
        sta $73
        clc

        jmp plotloop16x16_y1_loop

    plotloop16x16_y1_exit:
    clc
    jmp plot_buffer_loop_next

plot8x8_y0:             ; $70,$71=source address
                        ; $72,$73=destination address
    ldy #15

    plotloop8x8_y0_0:
        lda ($70),y
        eor ($72),y
        sta ($72),y
        dey
        bpl plotloop8x8_y0_0
    clc

    jmp plot_buffer_loop_next

; Sprite data stored in memory: 00 04
;
; Write to screen in this arrangement:
; --
; 00
;
; 04

plot8x8_y1:             ; $70,$71=source address
                        ; $72,$73=destination address

    ldx #1

    plotloop8x8_y1_loop:

        ldy #3

        plotloop8x8_y1_0:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            bpl plotloop8x8_y1_0
        clc

        ldy #11

        plotloop8x8_y1_1:
            lda ($70),y
            eor ($72),y
            sta ($72),y
            dey
            cpy #8
            bpl plotloop8x8_y1_1
        clc

        dex
        bmi plot8x8_y1_exit
        clc

        lda $70         ; add by 4 to start the next half row
        adc #4
        sta $70
        lda $71
        adc #0
        sta $71
        clc

        lda $72         ; subtract by 0x140 - 4 to plot the next top half row
        adc #$3c
        sta $72
        lda $73
        adc #$01
        sta $73
        clc

        jmp plotloop8x8_y1_loop

    plot8x8_y1_exit:
    clc

    jmp plot_buffer_loop_next


check_key:      ; x=key code
    lda #129    ; returns y=255 or 0
    ldy #255
    jsr $fff4
    rts

key_input:              ; returns A=0 (no key), 1 (left), 2 (right), 3 (up)
                        ;           4 (down), 5 (fire)

    ldx #158            ; -98 (Z)
    jsr check_key
    cpy #255
    bne not_left_key
    lda #1
    rts

not_left_key:
    ldx #189            ; -67 (X)
    jsr check_key
    cpy #255
    bne not_right_key
    lda #2
    rts

not_right_key:
    ldx #183            ; -73 (:)
    jsr check_key
    cpy #255
    bne not_up_key
    lda #3
    rts

not_up_key:
    ldx #151            ; -105 (/)
    jsr check_key
    cpy #255
    bne not_down_key
    lda #4
    rts

not_down_key:
    ldx #182            ; -74 (Return)
    jsr check_key
    cpy #255
    bne not_fire_key
    lda #5
    rts

not_fire_key:
    lda #0
    rts

player_direction_chars_low: .byte $00,$30,$60,$90,$c0,$f0,$20,$50
player_direction_chars_high: .byte $34,$34,$34,$34,$34,$34,$35,$35

screen_rows_low: .byte $80,$40,$00,$c0,$80,$40,$00,$c0,$80,$40
screen_rows_high: .byte $5a,$5e,$62,$65,$69,$6d,$71,$74,$78,$7c
screen_subrows_low: .byte $00,$04,$40,$44,$80,$84
screen_subrows_high: .byte $00,$00,$01,$01,$02,$02

screen_columns_low: .byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00,$20
screen_columns_high: .byte $00,$00,$00,$00,$00,$00,$00,$00,$01,$01
screen_subcolumns_low: .byte $00,$08,$10,$18

enemy_direction_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80
enemy_direction_chars_high: .byte $36,$37,$37,$37,$37,$38,$38,$38

emerge_explode_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$00,$00
emerge_explode_chars_high: .byte $40,$41,$41,$41,$41,$42,$42,$42

item_chars_low:  .byte $c0,$00,$40,$80,$c0,$00,$40,$80,$c0
item_chars_high: .byte $42,$43,$43,$43,$43,$44,$44,$44,$44

projectile_chars_low: .byte $40,$50,$60,$70,$80,$90,$a0,$b0

unplot_character:       ; $74,$75=character address

    lda $82             ; store the unplot buffer address in $78,$79
    sta $78
    lda $83
    sta $79
    jsr plot_character_sprite
    lda $78
    sta $82             ; update the latest space in the unplot buffer
    rts

plot_character:         ; $74,$75=character address

    lda $84             ; store the plot buffer address in $78,$79
    sta $78
    lda $85
    sta $79
    jsr plot_character_sprite
    lda $78
    sta $84             ; update the latest space in the plot buffer
    rts

plot_character_sprite:  ; $74,$75=character address
                        ; $78,$79=unplot/plot buffer address

    ldy #0
    lda ($74),y
    cmp #0
    bne plot_characters_read_character
    jmp plot_characters_next

    plot_characters_read_character:
    clc

    sta $77         ; temporarily store the object type

    ; Use lookup tables to load the offsets into the sprite.

    ; Direction
    iny
    lda ($74),y
    sta $80         ; temporarily store the direction

    ; y
    iny
    lda ($74),y
    tax
    lda screen_rows_low,x
    sta $72
    lda screen_rows_high,x
    sta $73
    clc

    ; dy
    iny
    lda ($74),y
    sta $76
    tax
    lda screen_subrows_low,x
    adc $72
    sta $72
    lda screen_subrows_high,x
    adc $73
    sta $73
    clc

    ; x
    iny
    lda ($74),y
    tax
    lda screen_columns_low,x
    adc $72
    sta $72
    lda screen_columns_high,x
    adc $73
    sta $73
    clc

    ; dx
    iny
    lda ($74),y
    tax
    lda screen_subcolumns_low,x
    adc $72
    sta $72
    clc

    lda $77
    cmp #1
    bne plot_characters_loop_not_player

    ; Plot 8x24 sprites (player)

    ldx $80
    lda player_direction_chars_low,x
    sta $70
    lda player_direction_chars_high,x
    sta $71

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    lda $76
    and #1
    bne plot_characters_plot_8x24_1

    lda #1
    sta ($78),y
    jmp plot_characters_stored

    plot_characters_plot_8x24_1:
    clc
    lda #2
    sta ($78),y
    jmp plot_characters_stored


    plot_characters_loop_not_player:
    cmp #2
    bne plot_characters_loop_not_projectile

    ; Plot 8x8 sprites (projectiles)

    lda $80
    and #7
    tax
    lda projectile_chars_low,x
    sta $70
    lda #$36
    sta $71

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    lda $76
    and #1
    bne plot_characters_plot_8x8_1

    lda #3
    sta ($78),y
    jmp plot_characters_stored

    plot_characters_plot_8x8_1:
    clc
    lda #4
    sta ($78),y
    jmp plot_characters_stored


    plot_characters_loop_not_projectile:
    cmp #3
    bne plot_characters_loop_not_explosion

    ; Plot 16x16 sprites (emerging, explosions)

    ; Select the sprites to use.

    lda $80
    and #3          ; only keep the bits required to find the correct sprite
    clc
    tax
    lda emerge_explode_chars_low,x
    sta $70
    lda emerge_explode_chars_high,x
    sta $71

    jmp plot_characters_16x16

    plot_characters_loop_not_explosion:
    cmp #4
    bne plot_characters_loop_not_item

    ; Plot 16x16 sprites (items)

    ; Select the sprites to use.

    lda $80
    and #7          ; only keep the bits required to find the correct sprite
    clc
    tax
    lda item_chars_low,x
    sta $70
    lda item_chars_high,x
    sta $71

    jmp plot_characters_16x16

    plot_characters_loop_not_item:
    cmp #8
    bmi plot_characters_loop_not_enemy

    ; Plot 16x16 sprites (enemies)

    ; Select the set of sprites to use.

    and #$70
    lsr
    lsr
    lsr     ; bits 4,5,6 >> 3 -> bits 1,2,3
    clc
    sta $71 ; 0x00, 0x02, 0x04, 0x06, 0x08

    lda $80
    and #7          ; keep the animation bits
    tax
    lda enemy_direction_chars_low,x
    sta $70
    lda enemy_direction_chars_high,x
    adc $71
    sta $71

    plot_characters_16x16:

    ; Use the dy value to determine which plotting routine to use.

    ldy #0
    lda $76
    and #1
    bne plot_characters_plot_16x16_1

    lda #5
    sta ($78),y
    jmp plot_characters_stored

    plot_characters_plot_16x16_1:
    clc
    lda #6
    sta ($78),y

    plot_characters_stored:

    iny
    lda $70
    sta ($78),y
    iny
    lda $71
    sta ($78),y
    iny
    lda $72
    sta ($78),y
    iny
    lda $73
    sta ($78),y

    clc
    lda $78
    adc #12
    sta $78

    plot_characters_loop_not_enemy:

    plot_characters_next:

    lda #255    ; terminate this stream of entries in the plot buffer
    ldy #0
    sta ($78),y
    clc
    rts

reset_plot_buffer:
    lda #$06    ; reset the index into the plot buffer
    sta $84
    lda #$52
    sta $85

    lda #255    ; terminate the plot list
    ldy #0
    sta ($84),y
    rts

reset_unplot_buffer:
    lda #$00    ; reset the index into the plot buffer
    sta $82
    lda #$52
    sta $83

    lda #255    ; terminate the unplot list
    ldy #0
    sta ($82),y
    rts

plot_buffer_types_low:  .byte <plot_buffer_loop_next, <plot8x24_y0, <plot8x24_y1, <plot8x8_y0, <plot8x8_y1, <plot16x16_y0, <plot16x16_y1
plot_buffer_types_high: .byte >plot_buffer_loop_next, >plot8x24_y0, >plot8x24_y1, >plot8x8_y0, >plot8x8_y1, >plot16x16_y0, >plot16x16_y1

plot_buffer:

    lda #$00
    sta $84
    lda #$52
    sta $85

    lda #6
    sta $88

    plot_buffer_loop:

        ldy #0
        lda ($84),y
        cmp #255
        beq plot_buffer_loop_skip

        clc
        tax
        lda plot_buffer_types_low,x
        sta $86
        lda plot_buffer_types_high,x
        sta $87

        iny
        lda ($84),y
        sta $70

        iny
        lda ($84),y
        sta $71

        iny
        lda ($84),y
        sta $72

        iny
        lda ($84),y
        sta $73

        jmp ($86)       ; returns to plot_buffer_loop_next

        plot_buffer_loop_skip:

        lda $88
        cmp #12
        beq plot_buffer_exit    ; both unplot and plot lists have terminated

        lda #12
        sta $88
        lda $84
        adc #6
        sta $84
        jmp plot_buffer_loop

        plot_buffer_loop_next:
        clc

        lda $84
        adc $88
        sta $84
        jmp plot_buffer_loop

    plot_buffer_exit:
    clc
    rts

room_row_offsets_low: .byte $9c,$a6,$b0,$ba,$c4,$ce,$d8,$e2,$ec,$f6

animate_player_left:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1
    eor #1      ; toggle animation flag
    sta $3301   ; left (directional bits are 0)

    jsr plot_character
    rts

animate_player_right:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #2      ; right
    sta $3301

    jsr plot_character
    rts

animate_player_up:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #4      ; up
    sta $3301

    jsr plot_character
    rts

animate_player_down:

    ; Set the direction and toggle the animation bit.

    lda $3301
    and #1      ; remove direction information (result is 0)
    eor #1      ; toggle animation flag
    ora #6      ; down
    sta $3301

    jsr plot_character
    rts

move_player:

    lda $33fe
    and #1
    beq move_player_allowed

    clc
    rts

    move_player_allowed:

    lda #$00    ; set up the address of the player character
    sta $74
    lda #$33
    sta $75

    ; Handle the left key.

    ldx #158            ; (Z)
    jsr check_key
    cpy #255
    bne move_player_not_left_key

    lda $3305           ; read dx
    cmp #0
    beq move_player_left_check_x

    jsr unplot_character        ; unplot the player character
    dec $3305
    clc
    jmp animate_player_left ; optimise away the rts
    
    move_player_left_check_x:   ; Check the x offset.

    lda $3304
    cmp #0
    beq move_player_leave_room_left

    clc
    tay
    dey                         ; x - 1
    lda $3302                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the left

    cmp #4                      ; check for the exit
    bne move_player_not_left_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_left_exit:
    cmp #0
    bne move_player_not_left_key

    lda $3303               ; dy
    cmp #0
    beq move_player_allow_left

    clc
    lda $70                 ; dy > 0 so we need to check another tile
    adc #10
    sta $70
    lda ($70),y             ; load the tile below and to the left

    cmp #0
    bne move_player_not_left_key

    move_player_allow_left:
    tya
    sta $81                 ; temporary
    jsr unplot_character    ; unplot the player character
    lda $81
    sta $3304               ; store the new room x offset
    lda #3
    sta $3305               ; dx = 3
    clc
    jmp animate_player_left ; optimise away the rts

    move_player_leave_room_left:
    sec
    lda $33f3
    sbc #1
    sta $33f3
    clc

    ; Set the player's position on the right of the screen.
    
    ; No need to unplot.

    lda #9      ; x = 9
    sta $3304
    lda #2      ; dx = 2
    sta $3305

    jsr animate_player_left
    sec                     ; indicate to the calling routine that the player
    rts                     ; has left the room

    move_player_not_left_key:

    ; Handle the right key.

    ldx #189            ; (X)
    jsr check_key
    cpy #255
    bne move_player_not_right_key

    lda $3305                   ; read dx
    cmp #2
    beq move_player_right_check_x
    cmp #3
    beq move_player_right_tile

    jsr unplot_character        ; unplot the player character
    inc $3305
    clc
    jmp animate_player_right    ; optimise away the rts
    
    move_player_right_check_x:  ; Check the x offset.

    lda $3304
    cmp #9
    beq move_player_leave_room_right

    clc
    tay
    iny                         ; x + 1
    lda $3302                   ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #4                      ; check for the exit
    bne move_player_not_right_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_right_exit:
    cmp #0
    bne move_player_not_right_key

    lda $3303                   ; dy
    cmp #0
    beq move_player_allow_right

    clc                         ; dy > 0 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_player_not_right_key

    move_player_allow_right:

    jsr unplot_character        ; unplot the player character
    inc $3305                   ; update dx
    clc
    jmp animate_player_right    ; optimise away the rts

    move_player_right_tile:

    jsr unplot_character    ; unplot the player character
    inc $3304               ; store the new room x offset
    lda #0
    sta $3305               ; dx = 0
    clc
    jmp animate_player_right ; optimise away the rts

    move_player_leave_room_right:
    clc
    lda $33f3
    adc #1
    sta $33f3
    clc

    ; Set the player's position on the left of the screen.

    ; No need to unplot.

    lda #0      ; x = 0
    sta $3304
    lda #0      ; dx = 0
    sta $3305

    jsr animate_player_right    
    sec                         ; indicate to the calling routine that the
    rts                         ; player has left the room

    move_player_not_right_key:

    ; Handle the up key.

    ldx #183            ; (:)
    jsr check_key
    cpy #255
    bne move_player_not_up_key

    lda $3303           ; read dy
    cmp #0
    beq move_player_up_check_y

    jsr unplot_character        ; unplot the player character
    dec $3303
    clc
    jmp animate_player_up       ; optimise away the rts
    
    move_player_up_check_y:     ; Check the y offset.

    lda $3302
    cmp #0
    beq move_player_leave_room_up

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    lda $3304                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #4                      ; check for the exit
    bne move_player_not_up_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_up_exit:
    cmp #0
    bne move_player_not_up_key

    lda $3305                   ; dx
    cmp #3
    bmi move_player_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_player_not_up_key

    move_player_allow_up:
    txa
    sta $81                 ; temporary
    jsr unplot_character    ; unplot the player character
    lda $81
    sta $3302               ; store the new room y offset
    lda #5
    sta $3303               ; dy = 5
    clc
    jmp animate_player_up   ; optimise away the rts

    move_player_leave_room_up:
    sec
    lda $33f2
    sbc #1
    sta $33f2
    clc

    ; Set the player's position on the bottom of the screen.

    ; No need to unplot.

    lda #9      ; y = 9
    sta $3302
    lda #0      ; dy = 0
    sta $3303

    jsr animate_player_up
    sec                     ; indicate to the calling routine that the player
    rts                     ; has left the room

    move_player_not_up_key:

    ; Handle the down key.

    ldx #151            ; (/)
    jsr check_key
    cpy #255
    bne move_player_not_down_key

    lda $3303                   ; read dy
    cmp #0
    beq move_player_down_check_y
    cmp #5
    beq move_player_down_tile

    jsr unplot_character        ; unplot the player character
    inc $3303                   ; 0 < dy < 5
    clc
    jmp animate_player_down    ; optimise away the rts
    
    move_player_down_check_y:  ; Check the y offset.

    lda $3302
    cmp #9
    beq move_player_leave_room_down

    clc
    tax
    inx                         ; y + 1
    lda $3304                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #4                      ; check for the exit
    bne move_player_not_down_exit
    jmp try_to_exit_level       ; optimise away the rts

    move_player_not_down_exit:
    cmp #0
    bne move_player_not_down_key

    lda $3305                   ; dx
    cmp #3
    bmi move_player_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_player_not_down_key

    move_player_allow_down:

    jsr unplot_character        ; unplot the player character
    inc $3303                   ; update dy
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_down_tile:

    jsr unplot_character        ; unplot the player character
    inc $3302                   ; store the new room y offset
    lda #0
    sta $3303                   ; dy = 0
    clc
    jmp animate_player_down     ; optimise away the rts

    move_player_leave_room_down:
    clc
    lda $33f2
    adc #1
    sta $33f2
    clc

    ; Set the player's position on the top of the screen.

    ; No need to unplot.

    lda #0      ; y = 0
    sta $3302
    lda #0      ; dy = 0
    sta $3303

    jsr animate_player_down
    sec                         ; indicate to the calling routine that the
    rts                         ; player has left the room

    move_player_not_down_key:
    clc
    rts

try_to_exit_level:
    lda $33f0
    and #$01
    beq try_to_exit_level_exit

    lda $33f0                   ; set the exit flag
    ora #$80
    sta $33f0
    sec                         ; indicate that the player is leaving the room
    rts

    try_to_exit_level_exit:
    clc
    rts

check_fire_key:

    lda $33fd
    bne check_fire_key_exit

    ldx #182            ; (Return)
    jsr check_key
    cpy #255
    bne check_fire_key_exit

    lda $3306
    cmp #0
    bne check_fire_key_exit

    lda #15
    sta $33fd

    jmp create_projectile   ; optimise away the rts

    check_fire_key_exit:
    clc
    rts

create_projectile:

    lda #2
    sta $3306

    lda $3301
    and #$06        ; copy the direction information
    asl
    asl
    asl
    ora $33f9       ; apply the projectile type
    sta $3307

    lda $3303       ; dy
    cmp #4
    bpl create_projectile_below

    clc
    adc #2
    sta $3309       ; dy + 2
    lda $3302       ; y
    sta $3308
    jmp create_projectile_continue

    create_projectile_below:
    sec
    sbc #4
    sta $3309       ; dy - 4
    clc
    lda $3302       ; y
    adc #1
    sta $3308

    create_projectile_continue:
    lda $3304       ; x
    sta $330a

    lda $3305       ; dx
    sta $330b

    lda #$06
    sta $74
    lda #$33
    sta $75
    jsr plot_character

    clc
    rts

emerge_type:                    ; returns A=type
    jsr unlimited_values
    lda $7d
    and #$70
    cmp #$40
    bmi exit_emerge_type

    lda #$40

    exit_emerge_type:
    clc
    rts

emerge_x_position:              ; returns A=position
    jsr unlimited_values
    lda $7d
    ora #2
    eor $3304
    and #7
    adc #1
    clc
    rts

emerge_y_position:              ; returns A=position
    jsr unlimited_values
    lda $7d
    ora #2
    eor $3302
    and #7
    adc #1
    clc
    rts

emerge_character:           ; $74,$75=character address

    lda #63
    sta $33ff

    jsr emerge_y_position     ; obtain a y position
    tax
    jsr emerge_x_position     ; obtain an x position
    sta $80                 ; temporary
    tay

    lda room_row_offsets_low,x
    sta $70
    lda #$57
    sta $71
    lda ($70),y             ; load the tile

    cmp #0
    bne emerge_character_exit

    ; There is a space in the room, so add an emerging enemy.

    ldy #0
    lda #3
    sta ($74),y

    jsr emerge_type         ; obtain an enemy type
    iny
    sta ($74),y

    txa
    iny
    sta ($74),y             ; store the y position
    lda #1
    iny
    sta ($74),y             ; store the dy offset

    lda $80
    iny
    sta ($74),y             ; store the x position
    lda #0
    iny
    sta ($74),y             ; store the dx offset

    jsr plot_character

    emerge_character_exit:
    clc
    rts

emerge_explode:             ; $74,$75=character address

    jsr unplot_character

    ldy #1
    lda ($74),y     ; direction/animation
    tax
    adc #1          ; update the counter
    and #3          ; mask off everything else
    sta $80         ; store the masked counter value
    bne move_characters_explosion_not_finished

    txa
    and #8
    bne move_characters_remove_character

    ; For emerges, convert into an enemy.
    txa
    and #$70        ; only keep bits 4,5,6
    ora #8          ; make this an enemy

    ldy #0
    sta ($74),y     ; update the type
    iny
    lda #0          ; prepare the direction and animation offset
    sta ($74),y

    jsr plot_character
    jmp emerge_explode_exit

    move_characters_remove_character:

    ; For finished explosions, just write 0 into the character array.
    lda #0
    ldy #0
    sta ($74),y
    jmp emerge_explode_exit

    move_characters_explosion_not_finished:
    txa
    and #$f8
    ora $80

    ldy #1
    sta ($74),y

    jsr plot_character

    emerge_explode_exit:
    clc
    rts

animate_enemy_left:     ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    and #$0b    ; keep vertical direction bit and animation bits
    sta ($74),y ; left (horizontal directional bit is 0)

    rts

move_enemy_left:        ; $74,$75=character address

    ldy #5
    lda ($74),y         ; read dx
    cmp #0
    beq move_enemy_left_check_x

    sec
    sbc #1
    ldy #5
    sta ($74),y                 ; dx
    clc
    jmp animate_enemy_left      ; optimise away the rts

    move_enemy_left_check_x:

    ; Check the x offset.

    ldy #4
    lda ($74),y                 ; x
    cmp #0
    beq move_enemy_left_exit

    sec
    sbc #1                      ; x - 1
    sta $81                     ; temporary
    ldy #2
    lda ($74),y                 ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    ldy $81                     ; temporary (x - 1)
    lda ($70),y                 ; load the tile to the left

    cmp #0
    bne move_enemy_left_exit

    ldy #3
    lda ($74),y                 ; dy
    cmp #3
    bmi move_enemy_allow_left

    clc
    lda $70                 ; dy > 2 so we need to check another tile
    adc #10
    sta $70
    ldy $81                 ; temporary (x - 1)
    lda ($70),y             ; load the tile below and to the left

    cmp #0
    bne move_enemy_left_exit

    move_enemy_allow_left:
    lda $81
    ldy #4
    sta ($74),y             ; store the new room x offset
    lda #3
    ldy #5
    sta ($74),y             ; dx = 3
    clc
    jmp animate_enemy_left ; optimise away the rts

    move_enemy_left_exit:
    sec
    rts

animate_enemy_right:    ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    ora #$04    ; right (keep vertical direction bit and animation bits)
    sta ($74),y

    rts

move_enemy_right:       ; $74,$75=character_address

    ldy #5
    lda ($74),y                 ; read dx
    cmp #0
    beq move_enemy_right_check_x
    cmp #3
    beq move_enemy_right_tile

    clc
    adc #1
    ldy #5
    sta ($74),y
    jmp animate_enemy_right    ; optimise away the rts
    
    move_enemy_right_check_x:  ; Check the x offset.

    ldy #4
    lda ($74),y                 ; x
    cmp #9
    beq move_enemy_right_exit

    clc
    adc #1                      ; x + 1
    sta $81                     ; temporary (x + 1)
    ldy #2
    lda ($74),y                 ; load the y offset
    tax                         ; as an index
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    ldy $81                     ; temporary (x + 1)
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_enemy_right_exit

    ldy #3
    lda ($74),y                 ; dy
    cmp #3
    bmi move_enemy_allow_right

    clc                         ; dy > 2 so we need to check another tile
    lda $70
    adc #10
    sta $70
    ldy $81                     ; temporary (x + 1)
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_enemy_right_exit

    move_enemy_allow_right:
    clc

    ldy #5
    lda ($74),y                 ; dx
    adc #1
    sta ($74),y                 ; update dx
    clc
    jmp animate_enemy_right    ; optimise away the rts

    move_enemy_right_tile:
    clc

    ldy #4
    lda ($74),y             ; x
    adc #1
    sta ($74),y             ; store the new room x offset
    lda #0
    iny
    sta ($74),y             ; dx = 0
    clc
    jmp animate_enemy_right ; optimise away the rts

    move_enemy_right_exit:
    sec
    rts

animate_enemy_up:   ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    and #$07    ; keep horizontal direction bit and animation bits
    sta ($74),y

    rts

move_enemy_up:      ; $74,$75=character address

    ldy #3
    lda ($74),y                 ; read dy
    cmp #0
    beq move_enemy_up_check_y

    sec
    sbc #1
    ldy #3
    sta ($74),y                 ; dy
    clc
    jmp animate_enemy_up        ; optimise away the rts
    
    move_enemy_up_check_y:

    ; Check the y offset.

    ldy #2
    lda ($74),y                 ; y
    cmp #0
    beq move_enemy_up_exit

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    ldy #4
    lda ($74),y                 ; load the x offset
    sta $81                     ; temporary (x)
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_enemy_up_exit

    ldy #5
    lda ($74),y                 ; dx
    cmp #0
    beq move_enemy_allow_up

    clc                     ; dx != 0 so we need to check another tile
    ldy $81
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_enemy_up_exit

    move_enemy_allow_up:
    txa
    ldy #2
    sta ($74),y             ; store the new room y offset
    lda #5
    iny
    sta ($74),y             ; dy = 5
    clc
    jmp animate_enemy_up   ; optimise away the rts

    move_enemy_up_exit:
    sec
    rts

animate_enemy_down: ; $74,$75=character address

    ; Set the direction and toggle the animation bit.

    ldy #1
    lda ($74),y
    ora #$08    ; down
    sta ($74),y

    rts

move_enemy_down:    ; $74,$75=character address    

    ldy #3
    lda ($74),y         ; dy
    cmp #2
    beq move_enemy_down_check_y
    cmp #5
    beq move_enemy_down_tile

    adc #1
    ldy #3
    sta ($74),y         ; dy
    clc
    jmp animate_enemy_down      ; optimise away the rts
    
    move_enemy_down_check_y:

    ; Check the y offset.

    ldy #2
    lda ($74),y
    cmp #9
    beq move_enemy_down_exit

    clc
    adc #1                      ; y + 1
    tax
    ldy #4
    lda ($74),y                 ; load the x offset
    sta $81                     ; temporary
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_enemy_down_exit

    ldy #5
    lda ($74),y                 ; dx
    cmp #0
    beq move_enemy_allow_down

    clc                         ; dx != 0 so we need to check another tile
    ldy $81                     ; x
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_enemy_down_exit

    move_enemy_allow_down:
    clc

    ldy #3
    lda ($74),y                 ; dy
    adc #1
    sta ($74),y                 ; update dy
    clc
    jmp animate_enemy_down      ; optimise away the rts

    move_enemy_down_tile:
    clc

    ldy #2
    lda ($74),y                 ; y
    adc #1
    sta ($74),y                 ; store the new room y offset
    lda #0
    iny
    sta ($74),y                 ; dy = 0
    clc
    jmp animate_enemy_down      ; optimise away the rts

    move_enemy_down_exit:
    sec
    rts

move_enemy_animate:     ; $74,$75=character address

    ldy #1
    lda ($74),y         ; direction/animation
    sta $81
    adc #1
    and #$03            ; keep animation bits
    sta $8f
    lda $81
    and #$0c            ; mask off the animation bits
    ora $8f
    sta ($74),y
    rts

move_enemy:             ; $74,$75=character address

    lda #0
    sta $8d
    lda #0
    sta $8e

    ldy #2
    lda ($74),y         ; y
    cmp $3302           ; player y
    bmi move_enemy_downwards
    bne move_enemy_upwards

    ldy #3
    lda ($74),y         ; dy
    cmp $3303           ; player y
    beq move_enemy_horizontally
    bpl move_enemy_upwards

    move_enemy_downwards:
    lda #2
    sta $8d
    jmp move_enemy_horizontally

    move_enemy_upwards:
    lda #1
    sta $8d
    ;jmp move_enemy_horizontally

    move_enemy_horizontally:
    ldy #4
    lda ($74),y         ; x
    cmp $3304           ; player x
    bmi move_enemy_rightwards
    bne move_enemy_leftwards

    ldy #5
    lda ($74),y         ; dx
    cmp #0
    beq move_enemy_with_direction
    bpl move_enemy_leftwards

    move_enemy_rightwards:
    lda #2
    sta $8e
    jmp move_enemy_with_direction

    move_enemy_leftwards:
    lda #1
    sta $8e

    move_enemy_with_direction:
    clc

    jsr unplot_character

    lda $8e
    cmp #1
    bne move_enemy_not_left
    jsr move_enemy_left
    clc
    jmp move_enemy_not_right

    move_enemy_not_left:
    lda $8e
    cmp #2
    bne move_enemy_not_right
    jsr move_enemy_right
    clc

    move_enemy_not_right:
    lda $8d
    cmp #1
    bne move_enemy_not_up
    jsr move_enemy_up
    clc
    jmp move_enemy_toggle

    move_enemy_not_up:
    lda $8d
    cmp #2
    bne move_enemy_toggle
    jsr move_enemy_down

    move_enemy_toggle:
    clc
    jsr move_enemy_animate
    jmp plot_character      ; optimise away the rts

    move_enemy_exit:
    clc
    rts

move_projectile_left:

    lda $330b
    cmp #0
    beq move_projectile_left_check_x

    dec $330b
    clc
    rts

    move_projectile_left_check_x:

    lda $330a
    cmp #0
    beq move_projectile_left_exit

    tay
    dey                         ; x - 1
    ldx $3308                   ; y
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the left

    cmp #0
    bne move_projectile_left_exit

    lda $3309                   ; dy
    cmp #5
    bmi move_projectile_allow_left

    clc                         ; dy > 4 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the left

    cmp #0
    bne move_projectile_left_exit

    move_projectile_allow_left:

    sty $330a       ; x
    lda #3
    sta $330b       ; dx = 3

    clc
    rts

    move_projectile_left_exit:
    sec
    rts

move_projectile_right:

    ; Fire right.

    lda $330b
    cmp #2
    beq move_projectile_right_check_x
    cmp #3
    beq move_projectile_right_tile

    inc $330b
    clc
    rts

    move_projectile_right_check_x:

    lda $330a       ; x
    cmp #9
    beq move_projectile_right_exit

    clc
    tay
    iny                         ; x + 1
    ldx $3308                   ; y
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile to the right

    cmp #0
    bne move_projectile_right_exit

    lda $3309                   ; dy
    cmp #5
    bmi move_projectile_allow_right

    clc                         ; dy > 4 so we need to check another tile
    lda $70
    adc #10
    sta $70
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_projectile_right_exit

    move_projectile_allow_right:

    inc $330b       ; dx
    clc
    rts

    move_projectile_right_tile:

    inc $330a       ; x
    lda #0
    sta $330b       ; dx
    clc
    rts

    move_projectile_right_exit:
    sec
    rts

move_projectile_up:

    lda $3309           ; read dy
    cmp #0
    beq move_projectile_up_check_y

    dec $3309
    clc
    rts
    
    move_projectile_up_check_y:     ; Check the y offset.

    lda $3308
    cmp #0
    beq move_projectile_up_exit

    tax                         ; use the y offset as an index
    dex                         ; y - 1
    lda $330a                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile above

    cmp #0
    bne move_projectile_up_exit

    lda $330b                   ; dx
    cmp #3
    bmi move_projectile_allow_up

    clc                     ; dx > 2 so we need to check another tile
    iny
    lda ($70),y             ; load the tile above and to the right

    cmp #0
    bne move_projectile_up_exit

    move_projectile_allow_up:
    txa
    sta $3308               ; store the new room y offset
    lda #5
    sta $3309               ; dy = 5

    clc
    rts

    move_projectile_up_exit:
    sec
    rts

move_projectile_down:

    lda $3309                   ; read dy
    cmp #4
    beq move_projectile_down_check_y
    cmp #5
    beq move_projectile_down_tile

    inc $3309                   ; 0 < dy < 5
    clc
    rts
    
    move_projectile_down_check_y:  ; Check the y offset.

    lda $3308
    cmp #9
    beq move_projectile_down_exit

    clc
    tax
    inx                         ; y + 1
    lda $330a                   ; load the x offset
    tay
    lda room_row_offsets_low,x  ; read the address of the row
    sta $70
    lda #$57
    sta $71
    lda ($70),y                 ; load the tile below

    cmp #0
    bne move_projectile_down_exit

    lda $330b                   ; dx
    cmp #3
    bmi move_projectile_allow_down

    clc                         ; dx > 2 so we need to check another tile
    iny
    lda ($70),y                 ; load the tile below and to the right

    cmp #0
    bne move_projectile_down_exit

    move_projectile_allow_down:

    inc $3309                   ; update dy
    clc
    rts

    move_projectile_down_tile:

    inc $3308                   ; store the new room y offset
    lda #0
    sta $3309                   ; dy = 0
    clc
    rts

    move_projectile_down_exit:
    sec
    rts

move_projectile_animate:

    lda $3307
    eor #1
    sta $3307
    rts

move_projectile:

    lda $3306
    cmp #0
    beq move_projectile_exit

    lda #$06
    sta $74
    lda #$33
    sta $75
    jsr unplot_character

    lda $3307
    and #$30            ; direction

    cmp #0
    bne move_projectile_not_left

    jsr move_projectile_left
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_left:
    cmp #$10
    bne move_projectile_not_right

    jsr move_projectile_right
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_right:
    cmp #$20
    bne move_projectile_not_up

    jsr move_projectile_up
    bcc move_projectile_toggle
    bcs move_projectile_destroy

    move_projectile_not_up:
    cmp #$30
    bne move_projectile_toggle

    jsr move_projectile_down
    bcs move_projectile_destroy

    move_projectile_toggle:

    jsr projectile_collide
    bcs move_projectile_destroy

    jsr move_projectile_animate

    lda #$06
    sta $74
    lda #$33
    sta $75
    jmp plot_character          ; optimise away the rts

    move_projectile_destroy:
    clc

    ldy #0
    lda ($74),y ; type
    cmp #8
    bmi move_projectile_no_enemy_collision

    ; Unplot the enemy and replace it with an explosion.

    jsr unplot_character

    lda #3      ; explosion
    ldy #0
    sta ($74),y

    lda #8
    ldy #1
    sta ($74),y

    jsr plot_character

    move_projectile_no_enemy_collision:

    lda #0                      ; remove the projectile from the character list
    sta $3306

    move_projectile_exit:
    clc
    rts

move_characters:

    lda #$0c            ; set the character address
    sta $74
    lda #$33
    sta $75

    move_characters_loop:

        ldy #0
        lda ($74),y
        cmp #0
        bne move_characters_read_character

        ; See if it is time to generate a new enemy.
        lda $33ff
        cmp #0
        bne move_characters_next

        jsr emerge_character
        jmp move_characters_next

        move_characters_read_character:
        clc

        move_characters_not_projectile:
        cmp #3
        bne move_characters_not_emerge_explode

        lda $33fe           ; check motion counter
        and #1
        bne move_characters_next

        jsr emerge_explode
        jmp move_characters_next

        move_characters_not_emerge_explode:
        cmp #8
        bmi move_characters_next

        lda $33fe           ; check motion counter
        and #3
        bne move_characters_next

        jsr move_enemy

        move_characters_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$24
        bpl move_characters_endloop
        sta $74
        jmp move_characters_loop

    move_characters_endloop:

    ; Check collisions with the player.

    jsr player_collide
    bcc move_characters_exit
    clc

    ldy #0
    lda ($74),y ; type
    cmp #8
    bpl move_character_destroy_enemy

    ; Unplot the item.
    jsr unplot_character

    ; Remove it from the item table.
    ldx $33f2
    lda eleven_times_table,x
    adc $33f3
    tax
    lda #0
    sta $5100,x

    lda #0      ; remove the item from the character list
    ldy #0
    sta ($74),y

    iny
    lda ($74),y         ; get the item type

    tax                 ; temporarily store A in X and increase the score
    lda item_scores,x
    jsr add_score
    txa

    ; Check the item type.
    cmp #5
    bmi move_characters_not_treasure

    rts

    move_characters_not_treasure:
    cmp #4
    bmi move_characters_not_key

    ; Key - update the item/player flags byte.
    lda $33f0
    ora #$01
    sta $33f0
    clc
    rts

    move_characters_not_key:

    ; Update the player's weapon.
    asl
    sta $33f9
    clc
    rts

    move_character_destroy_enemy:
    
    ; Unplot the enemy and replace it with an explosion.

    jsr unplot_character

    lda #3      ; explosion
    ldy #0
    sta ($74),y

    lda #8
    ldy #1
    sta ($74),y

    jsr plot_character

    move_characters_exit:
    clc
    rts

item_scores: .byte 10,10,10,10, 50,100,150,200,250

add_score:      ; $70=score to add

    lda $33f6
    adc $70
    sta $33f6
    lda $33f7
    adc #0
    sta $33f7
    lda $33f8
    adc #0
    sta $33f8
    clc
    rts

remove_characters:

    ; Clear the character table.

    ldx #6
    remove_characters_loop:
        lda #0
        sta $3300,x
        txa
        adc #6
        tax
        cpx #$24
        bmi remove_characters_loop

    rts

; The player collision masks use bits to represent where the player is in a
; tile.

; Player is above, enemy is below, checking the overlap in the lower tile.
player_collision_mask_above: .byte $00, $20, $30, $38, $3c, $3e

projectile_collision_mask_above: .byte $00, $00, $00, $00, $00, $20

; Player and enemy share the same tile or player is on the tile below.
player_collision_mask_below:  .byte $3f, $1f, $0f, $07, $03, $01

projectile_collision_mask_below: .byte $30, $18, $0c, $06, $03, $01

; Player is above or on the same tile, enemy is below, checking the overlap in
; the lower tile.
enemy_collision_mask_above:  .byte $3c, $1e, $0f, $07, $03, $01

; Enemy is above, player is below, checking the overlap in the lower tile.
enemy_collision_mask_below: .byte $00, $00, $00, $20, $30, $38

; Player is to the left, enemy is to the right, checking the overlap in the
; right hand tile.
player_collision_mask_left:
projectile_collision_mask_left: .byte $00, $00, $00, $08

; Player and enemy share the same tile or player is on the tile to the right.
player_collision_mask_right:
projectile_collision_mask_right: .byte $0c, $06, $03, $01

; Player is to the left, enemy is to the right or on the same tile, checking
; the overlap in the right hand tile.
enemy_collision_mask_left:  .byte $0f, $07, $03, $01

; Enemy is to the left, player is to the right, checking the overlap in the
; right hand tile.
enemy_collision_mask_right: .byte $00, $08, $0c, $0e

player_collide:

    lda $3302                           ; player y
    sta $8a
    lda $3304                           ; player x
    sta $8b

    ldx $3303                           ; player dy
    lda player_collision_mask_above,x
    sta $86
    lda player_collision_mask_below,x
    sta $88
    ldx $3305                           ; player dx
    lda player_collision_mask_left,x
    sta $87
    lda player_collision_mask_right,x
    sta $89

    jmp collide ; optimise away the rts

projectile_collide:

    lda $3308                           ; projectile y
    sta $8a
    lda $330a                           ; projectile x
    sta $8b

    ldx $3309                           ; projectile dy
    lda projectile_collision_mask_above,x
    sta $86
    lda projectile_collision_mask_below,x
    sta $88
    ldx $330b                           ; projectile dx
    lda projectile_collision_mask_left,x
    sta $87
    lda projectile_collision_mask_right,x
    sta $89

    jmp collide ; optimise away the rts

collide:

    lda #$0c            ; set the character address
    sta $74
    lda #$33
    sta $75

    collide_loop:

        ldy #0
        lda ($74),y         ; type
        cmp #4
        bpl collide_check

        jmp collide_next

        collide_check:

        ldy #2
        lda ($74),y         ; y
        sec
        sbc $8a             ; y - player/projectile y
        beq check_collide_y_equal
        cmp #1
        beq check_collide_y_greater
        cmp #255
        beq check_collide_y_less

        jmp collide_next

        check_collide_y_equal:
        ; The enemy is on the same tile as the player/projectile so look at the
        ; collision on their common tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_above,x
        and $88                             ; player/projectile mask below
        bne check_collide_x

        jmp collide_next

        check_collide_y_greater:
        ; The enemy is on the tile below the player/projectile so look at the
        ; collision on the enemy's tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_above,x
        and $86                             ; player mask above
        bne check_collide_x

        jmp collide_next

        check_collide_y_less:
        ; The enemy is on the tile above the player/projectile so look at the
        ; collision on the player's tile.
        ldy #3
        lda ($74),y                         ; dy
        tax
        lda enemy_collision_mask_below,x
        and $88                             ; player mask below
        bne check_collide_x

        jmp collide_next

        check_collide_x:
        ldy #4
        lda ($74),y         ; x
        sec
        sbc $8b             ; x - player/projectile x
        beq check_collide_x_equal
        cmp #1
        beq check_collide_x_greater
        cmp #255
        beq check_collide_x_less

        jmp collide_next

        check_collide_x_equal:
        ; The enemy is on the same tile as the player/projectile so look at the
        ; collision on their common tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_left,x
        and $89                             ; player mask right
        bne check_collide_destroy

        jmp collide_next

        check_collide_x_greater:
        ; The enemy is the tile to the right of the player/projectile so look
        ; at the collision on the enemy's tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_left,x
        and $87                             ; player mask left
        bne check_collide_destroy

        jmp collide_next

        check_collide_x_less:
        ; The enemy is the tile to the left of the player/projectile so look at
        ; the collision on the player's tile.
        ldy #5
        lda ($74),y                         ; dx
        tax
        lda enemy_collision_mask_right,x
        and $89                             ; player mask right
        bne check_collide_destroy

        collide_next:
        clc

        ; Examine the next character.
        lda $74
        adc #6

        cmp #$24
        bpl collide_exit
        sta $74
        jmp collide_loop

    check_collide_destroy:

    sec         ; set the carry flag to inform the caller that the
    rts         ; player/projectile should be destroyed

    collide_exit:
    clc
    rts

set_palette:
                    ; $70=logical colour
                    ; $71=physical colour
    lda $70
    sta $33fb
    lda $71
    sta $33fc
    lda #0
    sta $33fd
    sta $33fe
    sta $33ff

    lda #$c         
    ldx #$fb
    ldy #$33
    jsr $fff1
    rts

blank_screen:
    lda #1
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #2
    sta $70
    lda #0
    sta $71
    jsr set_palette
    lda #3
    sta $70
    lda #0
    sta $71
    jsr set_palette
    rts

sprites_file_name: .byte "SPRITES", 13
chars_file_name: .byte "CHARS", 13

sprites_block: .byte <sprites_file_name, >sprites_file_name
               .byte 0, $53, 0, 0
               .byte 0, $53, 0, 0
               .byte $60, $03, 0, 0
               .byte $60, $56, 0, 0

chars_block: .byte <chars_file_name, >chars_file_name
               .byte $00, $34, 0, 0
               .byte $00, $34, 0, 0
               .byte $80, $12, 0, 0
               .byte $80, $46, 0, 0

init:
    lda #255
    ldx #<sprites_block
    ldy #>sprites_block
    jsr $ffdd

    lda #255
    ldx #<chars_block
    ldy #>chars_block
    jsr $ffdd

    lda #22         ; MODE 5
    jsr $ffee
    lda #5
    jsr $ffee

    lda #23         ; disable flashing cursor
    jsr $ffee
    lda #1
    jsr $ffee
    ldx #7
    cursor_loop:
        lda #0
        jsr $ffee
        dex
        bpl cursor_loop

    lda #2
    sta $70
    lda #2
    sta $71
    jsr set_palette

    lda #3
    sta $70
    lda #3
    sta $71
    jsr set_palette

    rts

seeds:         .byte 100, 26, 33
start_rooms_x: .byte 5,   0,  10
start_rooms_y: .byte 5,   9,  0
exit_rooms_x:  .byte 7,   10, 2
exit_rooms_y:  .byte 0,   4,  10

; These values need to be kept in sync - the room numbers must match their
; positions in the room array.
key_rooms_x:   .byte 1,   9,  10
key_rooms_y:   .byte 0,   0,  6
key_rooms:     .byte 1, 9, 76

status_vdu_bytes: .byte 31,1,0, 17,3, "Score", 31,11,0, 17,2, "Strength"
; TAB(1,0), COLOUR 3, TAB(12,0), COLOUR 2

start_new_game:

    ; Clear the screen.
    lda #12
    jsr $ffee

    ; Write the status text.
    ldx #0
    write_status_text_loop:
        lda status_vdu_bytes,x
        jsr $ffee
        inx
        cpx #23
        bmi write_status_text_loop

    ; Set level.

    lda #0
    sta $33fa

    ; Set the projectile type.
    lda #0
    sta $33f9

    rts

start_level:

    ; Clear the item/player flags.
    lda #0
    sta $33f0

    ; Set current room.

    ldx $33fa
    lda start_rooms_y,x
    sta $33f2
    lda start_rooms_x,x
    sta $33f3

    ; Set the player position.

    lda #1      ; player
    sta $3300
    lda #6      ; down (first frame)
    sta $3301
    lda #5      ; y=5
    sta $3302
    lda #0      ; dy=0
    sta $3303
    lda #5      ; x=5
    sta $3304
    lda #0      ; dx=0
    sta $3305

    ; Fill the treasure table with objects.
    lda $33fa   ; level
    tax
    lda key_rooms,x
    sta $80
    
    lda $33fa   ; level
    and #31
    sta $7c
    lda #10
    sta $7d

    ldx #121
    start_level_add_treasure_loop:

        cpx $80                 ; check for the key room
        bne start_level_add_treasure_item

        lda #5                  ; the value is type + 1
        sta $5100,x
        jmp start_level_add_treasure_next

        start_level_add_treasure_item:
        jsr unlimited_values
        and #7                  ; restrict the value returned
        adc #1
        cmp #5                  ; do not allow keys to be added as normal items
        beq start_level_add_treasure_next

        sta $5100,x             ; add the item to the table

        start_level_add_treasure_next:
        dex
        bpl start_level_add_treasure_loop

    rts

main:
    jsr init

    main_loop:

        main_wait_loop:
            lda #129
            ldx #157
            ldy #255
            jsr $fff4
            cpy #255
            bne main_wait_loop

        jsr start_new_game

        level_loop:
            jsr start_level

            game_loop:

                jsr remove_characters

                jsr reset_unplot_buffer
                jsr reset_plot_buffer

                lda $33f2       ; current room (y)
                sta $78
                lda $33f3       ; current room (x)
                sta $79
                jsr plot_room
                jsr add_treasure

                lda #$00        ; plot the player
                sta $74
                lda #$33
                sta $75
                jsr plot_character

                jsr plot_buffer

                lda #0         ; reset projectile counter
                sta $33fd

                lda #0         ; reset motion counter
                sta $33fe

                lda #63         ; reset generation counter
                sta $33ff

                room_loop:
                    jsr reset_unplot_buffer
                    jsr reset_plot_buffer
                    jsr move_characters
                    jsr move_projectile

                    jsr check_fire_key
                    jsr move_player
                    bcs after_room_loop

                    lda #19
                    jsr $fff4
                    jsr plot_buffer

                    ldx #157
                    jsr check_key
                    cpy #255
                    beq exit
                    clc

                    lda $33fd
                    cmp #0
                    beq room_loop_no_update_projectile_counter

                    dec $33fd

                    room_loop_no_update_projectile_counter:

                    dec $33ff   ; update generation counter

                    inc $33fe   ; update motion counter
                    clc
                    jmp room_loop

                after_room_loop:
                clc

                lda $33f0
                and #$80
                bne exit_level

                jmp game_loop

            exit_level:
            inc $33fa
            jmp level_loop

        jmp main_loop

    exit:
    clc
    rts
